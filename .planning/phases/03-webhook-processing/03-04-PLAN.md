---
phase: 03-webhook-processing
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/divine/alerting.service.ts
  - backend/src/services/divine/slack.service.ts
  - backend/src/config/env.ts
autonomous: true
user_setup:
  - service: sendgrid
    why: "Email alerting for critical errors"
    env_vars:
      - name: ALERT_EMAIL_ENABLED
        source: "Set to 'true' to enable email alerts"
      - name: ALERT_EMAIL_RECIPIENTS
        source: "Comma-separated email addresses for alerts"
    dashboard_config: []
  - service: twilio
    why: "SMS alerting for critical errors"
    env_vars:
      - name: ALERT_SMS_ENABLED
        source: "Set to 'true' to enable SMS alerts"
      - name: ALERT_SMS_RECIPIENTS
        source: "Comma-separated phone numbers for alerts"
    dashboard_config: []

must_haves:
  truths:
    - "Critical errors send alerts to Slack, email, and SMS"
    - "Error severity determines which channels are used"
    - "Alert throttling prevents notification fatigue"
  artifacts:
    - path: "backend/src/services/divine/alerting.service.ts"
      provides: "Multi-channel alerting service"
      exports: ["alertingService", "sendAlert", "AlertSeverity"]
    - path: "backend/src/config/env.ts"
      provides: "Alert configuration env vars"
      contains: "ALERT_EMAIL_ENABLED"
  key_links:
    - from: "backend/src/services/divine/alerting.service.ts"
      to: "backend/src/services/divine/slack.service.ts"
      via: "import and delegation"
      pattern: "slackService\\.send"
    - from: "backend/src/services/divine/alerting.service.ts"
      to: "backend/src/services/messaging/sendgrid.service.ts"
      via: "import for email alerts"
      pattern: "sendgrid|SendGridService"
---

<objective>
Implement multi-channel error alerting (Slack, email, SMS) per CONTEXT.md decisions.

Purpose: Per CONTEXT.md, critical errors should alert via Slack, email, AND SMS. Currently only Slack is implemented. This plan adds email and SMS channels with smart throttling to prevent alert fatigue.

Output: Unified alerting service that routes alerts to appropriate channels based on severity.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-webhook-processing/03-CONTEXT.md

# Key source files
@backend/src/services/divine/slack.service.ts
@backend/src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add alerting configuration to env</name>
  <files>backend/src/config/env.ts</files>
  <action>
Add new environment variables for multi-channel alerting. Find the existing env configuration and add these fields:

```typescript
// Alert Configuration
ALERT_EMAIL_ENABLED: z.string().optional().default('false'),
ALERT_EMAIL_RECIPIENTS: z.string().optional().default(''),  // Comma-separated emails
ALERT_SMS_ENABLED: z.string().optional().default('false'),
ALERT_SMS_RECIPIENTS: z.string().optional().default(''),    // Comma-separated phones
ALERT_THROTTLE_MINUTES: z.string().optional().default('15'), // Digest interval
```

The exact syntax depends on how env.ts is structured. If it uses Zod schema:
```typescript
const envSchema = z.object({
  // ... existing fields ...

  // Alert Configuration
  ALERT_EMAIL_ENABLED: z.string().optional().default('false'),
  ALERT_EMAIL_RECIPIENTS: z.string().optional().default(''),
  ALERT_SMS_ENABLED: z.string().optional().default('false'),
  ALERT_SMS_RECIPIENTS: z.string().optional().default(''),
  ALERT_THROTTLE_MINUTES: z.string().optional().default('15'),
});
```

If it uses a simple export:
```typescript
export default {
  // ... existing fields ...

  // Alert Configuration
  ALERT_EMAIL_ENABLED: process.env.ALERT_EMAIL_ENABLED === 'true',
  ALERT_EMAIL_RECIPIENTS: process.env.ALERT_EMAIL_RECIPIENTS?.split(',').filter(Boolean) || [],
  ALERT_SMS_ENABLED: process.env.ALERT_SMS_ENABLED === 'true',
  ALERT_SMS_RECIPIENTS: process.env.ALERT_SMS_RECIPIENTS?.split(',').filter(Boolean) || [],
  ALERT_THROTTLE_MINUTES: parseInt(process.env.ALERT_THROTTLE_MINUTES || '15'),
};
```

Also add these to the .env.example file if it exists.
  </action>
  <verify>
1. Grep for new env vars: `grep "ALERT_EMAIL_ENABLED" backend/src/config/env.ts`
2. TypeScript compiles: `cd backend && npx tsc --noEmit`
  </verify>
  <done>Alert configuration environment variables added to env.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create unified alerting service</name>
  <files>backend/src/services/divine/alerting.service.ts</files>
  <action>
Create a new unified alerting service that routes to Slack, email, and SMS:

```typescript
/**
 * Multi-Channel Alerting Service
 * Routes alerts to Slack, email, and SMS based on severity and configuration.
 * Per CONTEXT.md: Multi-channel alerts with smart throttling.
 */
import { logger } from '../../utils/logger';
import { slackService, AlertSeverity } from './slack.service';
import env from '../../config/env';

// Re-export AlertSeverity for convenience
export { AlertSeverity };

export interface Alert {
  severity: AlertSeverity;
  title: string;
  message: string;
  clientId?: string;
  callId?: string;
  error?: Error;
  metadata?: Record<string, unknown>;
}

interface AlertThrottleEntry {
  count: number;
  firstSeen: Date;
  lastSeen: Date;
}

/**
 * Alerting service that routes to multiple channels based on severity.
 *
 * Severity routing:
 * - info: Slack only
 * - warning: Slack only
 * - error: Slack + email
 * - critical: Slack + email + SMS
 */
export class AlertingService {
  private throttleMap: Map<string, AlertThrottleEntry> = new Map();
  private readonly throttleMinutes: number;
  private readonly emailEnabled: boolean;
  private readonly smsEnabled: boolean;
  private readonly emailRecipients: string[];
  private readonly smsRecipients: string[];

  constructor() {
    // Parse env config
    this.throttleMinutes = typeof env.ALERT_THROTTLE_MINUTES === 'number'
      ? env.ALERT_THROTTLE_MINUTES
      : parseInt(String(env.ALERT_THROTTLE_MINUTES) || '15');

    this.emailEnabled = env.ALERT_EMAIL_ENABLED === true ||
      env.ALERT_EMAIL_ENABLED === 'true';

    this.smsEnabled = env.ALERT_SMS_ENABLED === true ||
      env.ALERT_SMS_ENABLED === 'true';

    this.emailRecipients = Array.isArray(env.ALERT_EMAIL_RECIPIENTS)
      ? env.ALERT_EMAIL_RECIPIENTS
      : String(env.ALERT_EMAIL_RECIPIENTS || '').split(',').filter(Boolean);

    this.smsRecipients = Array.isArray(env.ALERT_SMS_RECIPIENTS)
      ? env.ALERT_SMS_RECIPIENTS
      : String(env.ALERT_SMS_RECIPIENTS || '').split(',').filter(Boolean);

    logger.info({
      emailEnabled: this.emailEnabled,
      smsEnabled: this.smsEnabled,
      emailRecipients: this.emailRecipients.length,
      smsRecipients: this.smsRecipients.length,
      throttleMinutes: this.throttleMinutes,
    }, 'AlertingService initialized');
  }

  /**
   * Send an alert to appropriate channels based on severity.
   */
  async send(alert: Alert): Promise<void> {
    const { severity, title, message, clientId, callId, error } = alert;

    // Check throttling
    const throttleKey = this.getThrottleKey(alert);
    const shouldSend = this.checkThrottle(throttleKey, severity);

    if (!shouldSend.immediate) {
      logger.debug({ throttleKey, count: shouldSend.count }, 'Alert throttled');
      return;
    }

    const promises: Promise<boolean>[] = [];

    // Slack: always send for all severities
    promises.push(
      slackService.send({
        severity,
        title: shouldSend.count > 1
          ? `${title} (${shouldSend.count} occurrences)`
          : title,
        message,
        clientId,
        callId,
        fields: error?.stack ? [{
          name: 'Stack Trace',
          value: '```' + error.stack.slice(0, 500) + '```',
        }] : undefined,
      })
    );

    // Email: send for error and critical
    if ((severity === 'error' || severity === 'critical') && this.emailEnabled) {
      promises.push(this.sendEmailAlert(alert, shouldSend.count));
    }

    // SMS: send for critical only
    if (severity === 'critical' && this.smsEnabled) {
      promises.push(this.sendSMSAlert(alert));
    }

    try {
      await Promise.all(promises);
    } catch (err) {
      logger.error({ error: err }, 'Failed to send some alerts');
    }
  }

  /**
   * Convenience method for critical alerts.
   */
  async critical(
    title: string,
    message: string,
    context?: { clientId?: string; callId?: string; error?: Error }
  ): Promise<void> {
    await this.send({
      severity: 'critical',
      title,
      message,
      ...context,
    });
  }

  /**
   * Convenience method for error alerts.
   */
  async error(
    title: string,
    message: string,
    context?: { clientId?: string; callId?: string; error?: Error }
  ): Promise<void> {
    await this.send({
      severity: 'error',
      title,
      message,
      ...context,
    });
  }

  /**
   * Convenience method for warning alerts.
   */
  async warning(
    title: string,
    message: string,
    context?: { clientId?: string }
  ): Promise<void> {
    await this.send({
      severity: 'warning',
      title,
      message,
      ...context,
    });
  }

  /**
   * Convenience method for info alerts.
   */
  async info(title: string, message: string): Promise<void> {
    await this.send({
      severity: 'info',
      title,
      message,
    });
  }

  /**
   * Send email alert using SendGrid.
   */
  private async sendEmailAlert(alert: Alert, occurrenceCount: number): Promise<boolean> {
    if (this.emailRecipients.length === 0) {
      logger.debug('No email recipients configured');
      return false;
    }

    try {
      // Dynamic import to avoid circular dependencies
      const { sendGridService } = await import('../messaging/sendgrid.service');

      const subject = `[${alert.severity.toUpperCase()}] ${alert.title}`;
      const body = this.formatEmailBody(alert, occurrenceCount);

      for (const recipient of this.emailRecipients) {
        await sendGridService.sendEmail({
          to: recipient.trim(),
          subject,
          text: body,
          html: `<pre>${body}</pre>`,
        });
      }

      logger.debug({ recipients: this.emailRecipients.length }, 'Email alerts sent');
      return true;
    } catch (error) {
      logger.error({ error }, 'Failed to send email alert');
      return false;
    }
  }

  /**
   * Send SMS alert using Twilio.
   */
  private async sendSMSAlert(alert: Alert): Promise<boolean> {
    if (this.smsRecipients.length === 0) {
      logger.debug('No SMS recipients configured');
      return false;
    }

    try {
      // Dynamic import to avoid circular dependencies
      const { twilioService } = await import('../messaging/twilio.service');

      // SMS should be short and actionable
      const message = `CRITICAL: ${alert.title}\n${alert.message.slice(0, 100)}${alert.message.length > 100 ? '...' : ''}`;

      for (const recipient of this.smsRecipients) {
        await twilioService.sendSMS({
          to: recipient.trim(),
          body: message,
        });
      }

      logger.debug({ recipients: this.smsRecipients.length }, 'SMS alerts sent');
      return true;
    } catch (error) {
      logger.error({ error }, 'Failed to send SMS alert');
      return false;
    }
  }

  /**
   * Format email body for alerts.
   */
  private formatEmailBody(alert: Alert, occurrenceCount: number): string {
    const lines = [
      `Severity: ${alert.severity.toUpperCase()}`,
      `Title: ${alert.title}`,
      occurrenceCount > 1 ? `Occurrences: ${occurrenceCount}` : '',
      '',
      'Message:',
      alert.message,
      '',
    ];

    if (alert.clientId) lines.push(`Client ID: ${alert.clientId}`);
    if (alert.callId) lines.push(`Call ID: ${alert.callId}`);

    if (alert.error?.stack) {
      lines.push('', 'Stack Trace:', alert.error.stack);
    }

    lines.push('', `Time: ${new Date().toISOString()}`);
    lines.push(`Environment: ${env.NODE_ENV}`);

    return lines.filter(Boolean).join('\n');
  }

  /**
   * Generate a throttle key for an alert.
   */
  private getThrottleKey(alert: Alert): string {
    // Group by title + clientId for throttling
    return `${alert.title}:${alert.clientId || 'global'}`;
  }

  /**
   * Check if an alert should be sent based on throttling rules.
   *
   * Per CONTEXT.md: Smart throttling - first occurrence immediate,
   * then digest every 15 min.
   */
  private checkThrottle(
    key: string,
    severity: AlertSeverity
  ): { immediate: boolean; count: number } {
    const now = new Date();
    const existing = this.throttleMap.get(key);

    // Critical alerts always send immediately
    if (severity === 'critical') {
      this.throttleMap.set(key, {
        count: 1,
        firstSeen: now,
        lastSeen: now,
      });
      return { immediate: true, count: 1 };
    }

    if (!existing) {
      // First occurrence - send immediately
      this.throttleMap.set(key, {
        count: 1,
        firstSeen: now,
        lastSeen: now,
      });
      return { immediate: true, count: 1 };
    }

    // Check if throttle window has passed
    const minutesSinceFirst = (now.getTime() - existing.firstSeen.getTime()) / 1000 / 60;

    if (minutesSinceFirst >= this.throttleMinutes) {
      // Throttle window passed - send digest with count
      const count = existing.count + 1;
      this.throttleMap.set(key, {
        count: 1,
        firstSeen: now,
        lastSeen: now,
      });
      return { immediate: true, count };
    }

    // Within throttle window - increment count, don't send
    this.throttleMap.set(key, {
      count: existing.count + 1,
      firstSeen: existing.firstSeen,
      lastSeen: now,
    });
    return { immediate: false, count: existing.count + 1 };
  }

  /**
   * Clear throttle state (useful for testing).
   */
  clearThrottle(): void {
    this.throttleMap.clear();
  }
}

export const alertingService = new AlertingService();

// Convenience function for quick alerts
export async function sendAlert(alert: Alert): Promise<void> {
  return alertingService.send(alert);
}
```
  </action>
  <verify>
1. Service file exists: `test -f backend/src/services/divine/alerting.service.ts`
2. TypeScript compiles: `cd backend && npx tsc --noEmit`
3. Exports correct: `grep "export.*alertingService" backend/src/services/divine/alerting.service.ts`
  </verify>
  <done>Multi-channel alerting service created with Slack, email, and SMS channels.</done>
</task>

<task type="auto">
  <name>Task 3: Update existing code to use alertingService</name>
  <files>backend/src/core/router.ts</files>
  <action>
Update CentralRouter to use the new alertingService instead of direct slackService calls:

1. Update import at top of file:
```typescript
import { alertingService } from '../services/divine/alerting.service';
// Remove: import { slackService } from '../services/divine/slack.service';
```

2. Replace slackService.sendWarning call (for slow context_request) with alertingService:
```typescript
// Send alert for slow context_request
alertingService.warning(
  'Slow context_request Response',
  `context_request took ${responseTime}ms (threshold: 500ms)`,
  { clientId: config.client_id }
).catch(err => {
  logger.error({ error: err }, 'Failed to send slow response alert');
});
```

3. Also update any slackService calls in error handlers to use alertingService.error:
```typescript
// Example: in catch blocks
alertingService.error(
  'Webhook Processing Error',
  `Failed to process ${eventType} for ${clientId}: ${error.message}`,
  { clientId, error }
).catch(() => {}); // Fire and forget
```

The alertingService.warning() method will only send to Slack (per severity rules), maintaining the same behavior while being ready for future severity escalations.
  </action>
  <verify>
1. TypeScript compiles: `cd backend && npx tsc --noEmit`
2. alertingService imported: `grep "alertingService" backend/src/core/router.ts`
3. No direct slackService imports in router: `grep "slackService" backend/src/core/router.ts | grep -v "^//" | wc -l` should be 0
  </verify>
  <done>CentralRouter uses alertingService for all alerts, enabling multi-channel routing.</done>
</task>

</tasks>

<verification>
Phase 03 Plan 04 verification:
1. TypeScript compiles: `cd backend && npx tsc --noEmit`
2. Alerting service exists: `test -f backend/src/services/divine/alerting.service.ts`
3. Env vars added: `grep "ALERT_EMAIL_ENABLED" backend/src/config/env.ts`
4. Router uses alertingService: `grep "alertingService" backend/src/core/router.ts`

Manual test:
1. Set `ALERT_EMAIL_ENABLED=true` and `ALERT_EMAIL_RECIPIENTS=test@example.com`
2. Trigger a critical error
3. Verify email is sent (or logged if SendGrid not configured)
</verification>

<success_criteria>
- alertingService routes to Slack/email/SMS based on severity
- Critical alerts go to all channels
- Error alerts go to Slack + email
- Warning/info alerts go to Slack only
- Throttling prevents duplicate alerts within 15 minutes
- CentralRouter uses alertingService instead of direct slackService
</success_criteria>

<output>
After completion, create `.planning/phases/03-webhook-processing/03-04-SUMMARY.md`
</output>
