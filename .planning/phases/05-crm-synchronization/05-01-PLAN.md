---
phase: 05-crm-synchronization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema/oauthTokens.ts
  - backend/src/db/schema/index.ts
  - backend/src/services/divine/oauth-token.service.ts
  - backend/src/services/divine/index.ts
autonomous: true

must_haves:
  truths:
    - "OAuth tokens persist across server restarts"
    - "Token refresh updates database with new access token"
    - "New refresh tokens from Zoho are captured and saved"
  artifacts:
    - path: "backend/src/db/schema/oauthTokens.ts"
      provides: "OAuth tokens database schema"
      contains: "oauth_tokens"
    - path: "backend/src/services/divine/oauth-token.service.ts"
      provides: "OAuthTokenService with getAccessToken and refreshToken methods"
      exports: ["OAuthTokenService", "oauthTokenService"]
  key_links:
    - from: "backend/src/services/divine/oauth-token.service.ts"
      to: "backend/src/db/schema/oauthTokens.ts"
      via: "drizzle query"
      pattern: "db\\.select\\(\\).*oauthTokens"
---

<objective>
Create database-backed OAuth token storage infrastructure.

Purpose: The current in-memory OAuth token caching is lost on server restart/redeploy, causing authentication failures. This is identified as a BLOCKER in STATE.md and the primary gap in 05-RESEARCH.md.

Output:
- `oauth_tokens` database table schema
- `OAuthTokenService` with token persistence and refresh
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-crm-synchronization/05-RESEARCH.md

# Reference patterns
@backend/src/db/schema/messageQueue.ts
@backend/src/services/divine/zoho-crm.service.ts
@backend/src/services/divine/zoho-calendar.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create oauth_tokens database schema</name>
  <files>backend/src/db/schema/oauthTokens.ts, backend/src/db/schema/index.ts</files>
  <action>
Create `backend/src/db/schema/oauthTokens.ts` with Drizzle schema:

```typescript
import { pgTable, uuid, varchar, text, timestamp, jsonb } from 'drizzle-orm/pg-core';

export const oauthTokens = pgTable('oauth_tokens', {
  id: uuid('id').primaryKey().defaultRandom(),
  clientId: varchar('client_id', { length: 255 }).notNull(),
  provider: varchar('provider', { length: 50 }).notNull(), // 'zoho_crm', 'zoho_calendar'

  // Token data
  accessToken: text('access_token'),
  refreshToken: text('refresh_token').notNull(),
  tokenExpiry: timestamp('token_expiry'),

  // Scope tracking
  scopes: text('scopes'), // Comma-separated scopes

  // Provider-specific metadata (api_domain, etc.)
  metadata: jsonb('metadata'),

  // Timestamps
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

// Add unique constraint via index: clientId + provider
// Note: Drizzle handles UNIQUE via .unique() in newer versions or via migration

export type OAuthToken = typeof oauthTokens.$inferSelect;
export type NewOAuthToken = typeof oauthTokens.$inferInsert;
```

Update `backend/src/db/schema/index.ts` to export the new schema:
- Add `export * from './oauthTokens';`

WHY this design:
- `provider` field distinguishes 'zoho_crm' vs 'zoho_calendar' (may use different scopes/tokens)
- `metadata` JSONB for provider-specific data like Zoho's api_domain
- Timestamps for audit trail and debugging token issues
  </action>
  <verify>Run `npm run build` in backend/ - should compile without errors</verify>
  <done>oauthTokens schema exists with all required fields, exported from schema index</done>
</task>

<task type="auto">
  <name>Task 2: Create OAuthTokenService with database persistence</name>
  <files>backend/src/services/divine/oauth-token.service.ts, backend/src/services/divine/index.ts</files>
  <action>
Create `backend/src/services/divine/oauth-token.service.ts`:

```typescript
import { db } from '../../db';
import { oauthTokens, OAuthToken } from '../../db/schema/oauthTokens';
import { eq, and } from 'drizzle-orm';
import { logger } from '../../utils/logger';
import env from '../../config/env';

interface TokenRefreshResponse {
  access_token: string;
  expires_in: number;
  refresh_token?: string; // Zoho may return new refresh token
  api_domain?: string;
}

export class OAuthTokenService {
  private readonly tokenEndpoint = 'https://accounts.zoho.com/oauth/v2/token';
  private readonly bufferMs = 5 * 60 * 1000; // 5 minutes before expiry

  /**
   * Get a valid access token for a client/provider combination.
   * Refreshes automatically if expired or about to expire.
   */
  async getAccessToken(
    clientId: string,
    provider: 'zoho_crm' | 'zoho_calendar',
    credentials: { clientId: string; clientSecret: string }
  ): Promise<string> {
    // 1. Check database for existing token
    const stored = await db.select()
      .from(oauthTokens)
      .where(and(
        eq(oauthTokens.clientId, clientId),
        eq(oauthTokens.provider, provider)
      ))
      .limit(1);

    const token = stored[0];

    if (token) {
      // Check if token is still valid
      if (token.accessToken && token.tokenExpiry) {
        if (token.tokenExpiry.getTime() - this.bufferMs > Date.now()) {
          logger.debug({ clientId, provider }, 'Using cached access token from database');
          return token.accessToken;
        }
      }

      // Token expired or about to expire - refresh it
      logger.debug({ clientId, provider }, 'Token expired, refreshing');
      return this.refreshAndStore(clientId, provider, token.refreshToken, credentials);
    }

    // No stored token - try to initialize from env vars (backward compatibility)
    const envRefreshToken = this.getEnvRefreshToken(provider);
    if (envRefreshToken) {
      logger.info({ clientId, provider }, 'Initializing token from env vars');
      return this.refreshAndStore(clientId, provider, envRefreshToken, credentials);
    }

    throw new Error(`No OAuth token found for ${clientId}/${provider}. Configure via env vars or database.`);
  }

  /**
   * Store initial tokens (called after OAuth authorization flow).
   */
  async storeTokens(
    clientId: string,
    provider: 'zoho_crm' | 'zoho_calendar',
    tokens: {
      accessToken?: string;
      refreshToken: string;
      expiresIn?: number;
      scopes?: string;
      metadata?: Record<string, unknown>;
    }
  ): Promise<void> {
    const tokenExpiry = tokens.expiresIn
      ? new Date(Date.now() + tokens.expiresIn * 1000)
      : null;

    await db.insert(oauthTokens)
      .values({
        clientId,
        provider,
        accessToken: tokens.accessToken || null,
        refreshToken: tokens.refreshToken,
        tokenExpiry,
        scopes: tokens.scopes || null,
        metadata: tokens.metadata || null,
      })
      .onConflictDoUpdate({
        target: [oauthTokens.clientId, oauthTokens.provider],
        set: {
          accessToken: tokens.accessToken || null,
          refreshToken: tokens.refreshToken,
          tokenExpiry,
          scopes: tokens.scopes || null,
          metadata: tokens.metadata || null,
          updatedAt: new Date(),
        },
      });

    logger.info({ clientId, provider }, 'OAuth tokens stored');
  }

  /**
   * Check if a token exists for a client/provider.
   */
  async hasToken(clientId: string, provider: 'zoho_crm' | 'zoho_calendar'): Promise<boolean> {
    const result = await db.select({ id: oauthTokens.id })
      .from(oauthTokens)
      .where(and(
        eq(oauthTokens.clientId, clientId),
        eq(oauthTokens.provider, provider)
      ))
      .limit(1);

    return result.length > 0 || Boolean(this.getEnvRefreshToken(provider));
  }

  /**
   * Refresh token and store new values.
   */
  private async refreshAndStore(
    clientId: string,
    provider: 'zoho_crm' | 'zoho_calendar',
    refreshToken: string,
    credentials: { clientId: string; clientSecret: string }
  ): Promise<string> {
    const response = await fetch(this.tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        client_id: credentials.clientId,
        client_secret: credentials.clientSecret,
        refresh_token: refreshToken,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      logger.error({ status: response.status, error: errorText, clientId, provider }, 'Token refresh failed');
      throw new Error(`Token refresh failed: ${response.status} - ${errorText}`);
    }

    const data = await response.json() as TokenRefreshResponse;

    // Calculate expiry
    const tokenExpiry = new Date(Date.now() + data.expires_in * 1000);

    // Update database (upsert pattern)
    await db.insert(oauthTokens)
      .values({
        clientId,
        provider,
        accessToken: data.access_token,
        refreshToken: data.refresh_token || refreshToken, // Use new refresh token if provided
        tokenExpiry,
        metadata: data.api_domain ? { api_domain: data.api_domain } : null,
      })
      .onConflictDoUpdate({
        target: [oauthTokens.clientId, oauthTokens.provider],
        set: {
          accessToken: data.access_token,
          refreshToken: data.refresh_token || refreshToken,
          tokenExpiry,
          updatedAt: new Date(),
        },
      });

    logger.debug({ clientId, provider, expiresIn: data.expires_in }, 'Token refreshed and stored');

    return data.access_token;
  }

  /**
   * Get refresh token from environment variables (backward compatibility).
   */
  private getEnvRefreshToken(provider: 'zoho_crm' | 'zoho_calendar'): string | null {
    // Both services currently use the same env var
    return env.ZOHO_REFRESH_TOKEN || null;
  }
}

export const oauthTokenService = new OAuthTokenService();
```

Update `backend/src/services/divine/index.ts` to export the new service:
- Add `export * from './oauth-token.service';`

WHY this implementation:
- Uses upsert (onConflictDoUpdate) for idempotent token storage
- Captures new refresh tokens if Zoho returns them (Zoho may rotate refresh tokens)
- Falls back to env vars for backward compatibility during migration
- 5-minute buffer prevents token expiry during requests
  </action>
  <verify>Run `npm run build` in backend/ - should compile without TypeScript errors</verify>
  <done>OAuthTokenService exists with getAccessToken, storeTokens, hasToken methods. Service exported from divine/index.ts.</done>
</task>

<task type="auto">
  <name>Task 3: Run database migration for oauth_tokens table</name>
  <files>backend/src/db/migrations/</files>
  <action>
Generate and run the Drizzle migration for the new oauth_tokens table.

1. Generate migration:
```bash
cd backend && npx drizzle-kit generate
```

2. If the project uses `drizzle-kit push` instead of migrations, run:
```bash
cd backend && npx drizzle-kit push
```

3. Verify table created by checking database or running a quick query test.

Note: The schema should have a unique constraint on (client_id, provider). If Drizzle doesn't add this automatically, add a migration or use:
```sql
CREATE UNIQUE INDEX IF NOT EXISTS oauth_tokens_client_provider_unique
ON oauth_tokens (client_id, provider);
```

This unique constraint is CRITICAL for the upsert pattern in OAuthTokenService.
  </action>
  <verify>Database has oauth_tokens table with columns: id, client_id, provider, access_token, refresh_token, token_expiry, scopes, metadata, created_at, updated_at. Unique constraint exists on (client_id, provider).</verify>
  <done>oauth_tokens table exists in database and accepts inserts/updates via OAuthTokenService</done>
</task>

</tasks>

<verification>
1. `npm run build` passes in backend/
2. Database has oauth_tokens table
3. Can import `{ oauthTokenService }` from divine services
4. TypeScript types compile correctly
</verification>

<success_criteria>
- OAuth tokens schema created and exported
- OAuthTokenService provides getAccessToken with DB persistence
- Token refresh captures and stores new refresh tokens
- Database migration applied successfully
- Backward compatibility with env vars maintained
</success_criteria>

<output>
After completion, create `.planning/phases/05-crm-synchronization/05-01-SUMMARY.md`
</output>
