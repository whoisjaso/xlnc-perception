---
phase: 04-follow-up-messaging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema/messageQueue.ts
  - backend/src/utils/business-hours.ts
  - backend/src/services/divine/queue-processor.service.ts
autonomous: true

must_haves:
  truths:
    - "Message queue schema supports message types and cost tracking"
    - "Dead letter queue status exists for permanently failed messages"
    - "Business hours utility correctly identifies marketing message windows"
    - "Fixed 1-minute retry intervals replace exponential backoff"
    - "Provider failover works when primary provider fails"
    - "Cost tracking populated after successful message send"
  artifacts:
    - path: "backend/src/db/schema/messageQueue.ts"
      provides: "Enhanced message queue schema with messageType, costCents, deadLetterAt"
      contains: "messageType"
    - path: "backend/src/utils/business-hours.ts"
      provides: "Business hours checking utility"
      exports: ["isWithinBusinessHours", "getNextBusinessHour"]
    - path: "backend/src/services/divine/queue-processor.service.ts"
      provides: "Fixed retry intervals, provider failover, cost tracking"
      contains: "60 * 1000"
  key_links:
    - from: "backend/src/utils/business-hours.ts"
      to: "client config business_hours"
      via: "business_hours field from client config"
      pattern: "business_hours"
    - from: "backend/src/services/divine/queue-processor.service.ts"
      to: "smsService/emailService"
      via: "failover on primary failure"
      pattern: "failover|backup"
---

<objective>
Enhance message queue schema and create foundation utilities for Phase 4 messaging features.

Purpose: The existing message queue schema lacks fields for message type classification, cost tracking, and dead letter handling. This plan adds these fields and creates the business hours utility needed for marketing message timing. Also implements provider failover per CONTEXT.md requirement.

Output: Enhanced schema with migration, business hours utility, fixed retry intervals, provider failover, and cost tracking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-follow-up-messaging/04-CONTEXT.md
@.planning/phases/04-follow-up-messaging/04-RESEARCH.md
@backend/src/db/schema/messageQueue.ts
@backend/src/services/divine/queue-processor.service.ts
@backend/src/services/divine/sms.service.ts
@backend/src/services/divine/email.service.ts
@backend/config/clients/smart-tax-nation.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance Message Queue Schema</name>
  <files>backend/src/db/schema/messageQueue.ts</files>
  <action>
Add the following fields to the messageQueue table schema:

1. `messageType` - varchar(50) for categorization: 'confirmation', 'reminder_24h', 'reminder_1h', 'nurture_day1', 'nurture_day4', 'post_call_followup', 'manual'
2. `costCents` - integer for per-message cost tracking (nullable, set after send)
3. `deadLetterAt` - timestamp for when message moved to dead letter status (nullable)
4. `deadLetterReason` - text for storing why permanently failed (nullable)
5. `providerUsed` - varchar(50) to track which provider actually sent (for failover tracking)

Update the status field comment to include 'dead_letter' as a valid status option.

Export the updated types.

DO NOT modify the existing fields - only add new ones.
  </action>
  <verify>Run `npx drizzle-kit generate:pg` to verify schema is valid (should generate migration file)</verify>
  <done>Schema file includes messageType, costCents, deadLetterAt, deadLetterReason, providerUsed fields with proper types</done>
</task>

<task type="auto">
  <name>Task 2: Create Business Hours Utility</name>
  <files>backend/src/utils/business-hours.ts</files>
  <action>
Create a new utility file for business hours checking. Use date-fns and date-fns-tz for timezone handling.

Install if needed: `npm install date-fns date-fns-tz`

Implement:

```typescript
interface BusinessHours {
  monday?: { start: string; end: string; closed?: boolean };
  tuesday?: { start: string; end: string; closed?: boolean };
  // ... same for all days
  sunday?: { start: string; end: string; closed?: boolean };
}

/**
 * Check if a given date/time falls within business hours
 * @param date The date to check
 * @param businessHours The business hours config from client config
 * @param timezone The client's timezone (e.g., 'America/New_York')
 * @returns true if within business hours
 */
export function isWithinBusinessHours(
  date: Date,
  businessHours: BusinessHours,
  timezone: string
): boolean

/**
 * Get the next available business hour if currently outside hours
 * @param date The starting date
 * @param businessHours The business hours config
 * @param timezone The client's timezone
 * @returns The next Date when business hours begin
 */
export function getNextBusinessHour(
  date: Date,
  businessHours: BusinessHours,
  timezone: string
): Date
```

Use `toZonedTime` from date-fns-tz to convert to client timezone.
Map day of week (0-6 where 0=Sunday) to day names in businessHours object.
Check if day is closed. If not, compare current time against start/end.
For getNextBusinessHour, iterate forward through days until finding an open day.

Add unit tests inline as JSDoc examples showing expected behavior.
  </action>
  <verify>Create a quick test script or add console.log testing to verify:
- Returns true for 10am Monday (within hours)
- Returns false for 2am Monday (outside hours)
- Returns false for Sunday (closed)
- getNextBusinessHour returns Monday 9am if called on Sunday</verify>
  <done>business-hours.ts exports isWithinBusinessHours and getNextBusinessHour with correct timezone handling</done>
</task>

<task type="auto">
  <name>Task 3: Fix Retry Intervals, Add Failover, Add Cost Tracking</name>
  <files>backend/src/services/divine/queue-processor.service.ts</files>
  <action>
Per CONTEXT.md requirements, update the queue processor with three changes:

**1. Fixed 1-minute retry intervals:**
Currently uses exponential backoff: `const retryDelayMs = Math.pow(2, attempts) * 1000`
Change to fixed 1-minute intervals: `const retryDelayMs = 60 * 1000` (60 seconds)

**2. Provider failover (CONTEXT.md: "Failover to backup: Twilio -> Text180 for SMS, SendGrid -> Zoho for email"):**

In processMessage(), wrap the send call in failover logic:

```typescript
// For SMS
if (message.channel === 'sms') {
  let result = await smsService.send(message.recipient, message.body);
  let providerUsed = 'twilio';

  // Failover to Text180 if Twilio fails
  if (!result.success && smsService.sendViaText180) {
    logger.warn({ messageId: message.id }, 'Twilio failed, attempting Text180 failover');
    result = await smsService.sendViaText180(message.recipient, message.body);
    providerUsed = 'text180';
  }

  if (result.success) {
    providerId = result.messageId;
    // Store which provider was used
  } else {
    throw new Error(result.error || 'SMS send failed on all providers');
  }
}

// For Email - similar pattern with SendGrid -> Zoho failover
```

Note: If sendViaText180/sendViaZoho methods don't exist on the services yet, add a TODO comment and use optional chaining (smsService.sendViaText180?.) to make it forward-compatible. The actual backup provider methods can be added later.

**3. Cost tracking after successful send:**

After marking message as sent, populate costCents based on channel:
- SMS: 0.75 cents per segment (standard Twilio rate), estimate 1 segment for messages under 160 chars
- Email: 0.1 cents per email (SendGrid rate)

```typescript
// Calculate cost after successful send
const costCents = message.channel === 'sms'
  ? Math.ceil(message.body.length / 160) * 0.75  // SMS segments
  : 0.1;  // Email flat rate

await db
  .update(messageQueue)
  .set({
    status: 'sent',
    providerId,
    providerUsed,
    providerStatus: 'delivered',
    processedAt: new Date(),
    lastAttemptAt: new Date(),
    costCents: Math.round(costCents * 100) / 100,  // Round to 2 decimal places as integer cents
  })
  .where(eq(messageQueue.id, message.id));
```

**4. Dead letter handling (existing requirement):**
When attempts >= maxAttempts, set status to 'dead_letter' instead of 'failed'.
Set deadLetterAt timestamp and deadLetterReason to the error message.

Update getStats to count 'dead_letter' status separately. Update QueueStats interface to include `deadLetter: number`.
  </action>
  <verify>Review the handleFailure method logic. Verify:
- retryDelayMs = 60000 (1 minute)
- Failover logic attempts backup provider on primary failure
- costCents populated after successful send
- status set to 'dead_letter' when maxAttempts reached
- deadLetterAt and deadLetterReason populated</verify>
  <done>Queue processor uses 1-minute fixed retry intervals, has provider failover logic, tracks cost per message, and properly handles dead letter status</done>
</task>

</tasks>

<verification>
1. Run `npx drizzle-kit generate:pg` - should create migration for new fields
2. Run `npm run build` - should compile without errors
3. Review business-hours.ts with manual timezone scenarios
4. Review queue-processor.service.ts retry logic, failover pattern, and cost tracking
</verification>

<success_criteria>
- Message queue schema has messageType, costCents, deadLetterAt, deadLetterReason, providerUsed fields
- business-hours.ts utility exports two functions with proper timezone handling
- Queue processor uses 60-second fixed retry intervals
- Failover logic attempts backup provider when primary fails
- costCents populated after successful message send
- Dead letter status properly implemented with timestamp and reason
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-follow-up-messaging/04-01-SUMMARY.md`
</output>
