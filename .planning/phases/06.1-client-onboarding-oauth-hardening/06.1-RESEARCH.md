# Phase 6.1: Client Onboarding & OAuth Hardening - Research

**Researched:** 2026-01-27
**Domain:** OAuth 2.0 token lifecycle, multi-tenant client provisioning
**Confidence:** HIGH

## Summary

This phase builds on a solid existing foundation. The codebase already has: `OAuthTokenService` with database-backed token storage, `ClientConfigService` with file-based JSON configs and Zod validation, JWT-based admin auth with `requireAdmin` middleware, and per-client Zoho CRM/Calendar OAuth via the `oauth_tokens` table (keyed by `clientId + provider`).

The main gaps are: (1) no OAuth authorization initiation flow (only refresh-token-based), (2) no token health monitoring or expiry alerting, (3) no guided onboarding workflow or setup validation, (4) `ClientConfigService.loadFromDatabase()` is a stub returning null.

**Primary recommendation:** Add OAuth authorization endpoints (initiate + callback), a token health check service with alerting, and a setup checklist endpoint -- all layered on existing services without restructuring.

## Standard Stack

### Core (Already in Use)
| Library | Purpose | Why Standard |
|---------|---------|--------------|
| Express + TypeScript | Backend framework | Already in use |
| Drizzle ORM + PostgreSQL | Database | Already in use |
| Zod | Validation (ClientConfigSchema) | Already in use |
| jsonwebtoken | Admin JWT auth | Already in use |

### Supporting (Add for This Phase)
| Library | Purpose | When to Use |
|---------|---------|-------------|
| crypto (Node built-in) | Generate OAuth `state` parameter | CSRF protection for OAuth callback |
| node-cron (if not present) | Scheduled token health checks | Periodic monitoring |

No new dependencies needed. Everything builds on existing Express routes, Drizzle schema, and OAuthTokenService.

## Architecture Patterns

### Recommended Structure
```
backend/src/
├── routes/
│   └── oauth.ts                    # New: OAuth initiation + callback routes
├── services/divine/
│   ├── oauth-token.service.ts      # Existing: extend with health check methods
│   ├── client-config.service.ts    # Existing: extend with setup validation
│   └── onboarding.service.ts       # New: orchestrates setup checklist
├── db/schema/
│   └── oauthTokens.ts              # Existing: add status/health fields
```

### Pattern 1: OAuth Authorization Code Flow (Zoho)
**What:** Admin initiates OAuth for a specific client, Zoho redirects back with auth code, server exchanges for tokens.
**When to use:** Initial CRM authorization and re-authorization after token expiry.

Zoho OAuth flow:
1. Admin hits `GET /api/oauth/authorize/:clientId?provider=zoho_crm`
2. Server generates `state` = `{clientId}:{random}`, stores in short-lived cache/DB
3. Redirect to `https://accounts.zoho.com/oauth/v2/auth?scope=ZohoCRM.modules.ALL&client_id=X&redirect_uri=Y&response_type=code&state=Z&access_type=offline`
4. Zoho redirects to `GET /api/oauth/callback` with `code` and `state`
5. Server exchanges code for tokens via `https://accounts.zoho.com/oauth/v2/token`
6. Stores tokens via existing `oauthTokenService.storeTokens()`

**Key Zoho detail:** `access_type=offline` is required to get a refresh token. `prompt=consent` forces re-consent for re-auth scenarios.

### Pattern 2: Token Health Monitoring
**What:** Periodic check of all OAuth tokens, flag unhealthy ones, alert admins.
**When to use:** Background job on interval (every 15-30 minutes).

Health states:
- `healthy` - refresh token present, last refresh succeeded
- `expiring` - access token expires within 1 hour, refresh not yet attempted
- `refresh_failed` - refresh attempt returned error (token may be revocable)
- `invalid` - refresh token rejected by provider (needs re-auth)

### Pattern 3: Setup Checklist
**What:** Endpoint returns validation status of all onboarding steps for a client.
**When to use:** Admin provisioning UI, setup verification.

```typescript
interface SetupChecklist {
  clientId: string;
  steps: {
    config_created: boolean;
    zoho_crm_authorized: boolean;
    zoho_calendar_authorized: boolean;
    crm_connection_verified: boolean;  // actually made a test API call
    calendar_connection_verified: boolean;
    sms_configured: boolean;
    email_configured: boolean;
    retell_configured: boolean;
    business_hours_set: boolean;
  };
  ready: boolean;  // all required steps complete
  issues: string[];
}
```

### Anti-Patterns to Avoid
- **Storing OAuth state in memory:** Use DB or Redis. Server restart during OAuth flow loses state.
- **Single refresh token for all clients:** Already avoided -- `oauth_tokens` table is per-client+provider.
- **Silent token failures:** Never swallow refresh errors. Log, mark unhealthy, alert.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| OAuth state parameter | Custom random string | `crypto.randomBytes(32).toString('hex')` | Cryptographic randomness needed |
| Token encryption at rest | Custom encryption | Keep current approach (DB-level) or add `crypto.createCipheriv` | Encryption is easy to get wrong |
| Zoho OAuth URLs | String concatenation | `URLSearchParams` for query building | Encoding edge cases |

## Common Pitfalls

### Pitfall 1: Zoho Refresh Token Invalidation
**What goes wrong:** Zoho refresh tokens can be invalidated if: (a) user revokes access in Zoho, (b) a new authorization generates a new refresh token (old one may become invalid), (c) refresh token unused for extended period.
**How to avoid:** Monitor refresh failures. On `invalid_grant` error from Zoho, mark token as `invalid` status and alert admin to re-authorize. Never retry a failed refresh in a tight loop.

### Pitfall 2: OAuth Callback Race Conditions
**What goes wrong:** Multiple admins initiate OAuth for same client simultaneously. Callback processes both, last one wins but first token stored may be overwritten.
**How to avoid:** Use the existing `clientId+provider` unique index. The upsert pattern in `storeTokens()` already handles this correctly.

### Pitfall 3: Missing `access_type=offline` on Zoho
**What goes wrong:** Without `access_type=offline`, Zoho returns only an access token (no refresh token). System works briefly then fails.
**How to avoid:** Always include `access_type=offline` and `prompt=consent` in authorization URL.

### Pitfall 4: Client Config Has Zoho Credentials but No OAuth Token
**What goes wrong:** `ClientConfig` has `zoho_client_id`/`zoho_client_secret` fields (API app credentials) but `oauth_tokens` table stores the user-level tokens. These are different things. Confusing them breaks auth.
**How to avoid:** Clear naming: API app credentials live in `ClientConfig` (or env vars). User OAuth tokens live in `oauth_tokens` table. The `ZohoCRMService.forClient()` pattern already separates these correctly.

### Pitfall 5: File-Based Config for Production Multi-Tenancy
**What goes wrong:** `ClientConfigService` saves to JSON files on disk. In multi-instance deployment, configs diverge between instances.
**How to avoid:** The `loadFromDatabase()` stub exists. For now, single-instance is fine. Flag as future work -- don't block this phase on DB migration of configs.

## Code Examples

### OAuth Authorization Initiation
```typescript
// Route: GET /api/oauth/authorize/:clientId
router.get('/authorize/:clientId', authenticateToken, requireAdmin, async (req, res) => {
  const { clientId } = req.params;
  const provider = req.query.provider as string || 'zoho_crm';

  // Load client config to get Zoho app credentials
  const config = await clientConfigService.getConfig(clientId);
  if (!config) return res.status(404).json({ error: 'Client not found' });

  const zohoClientId = config.zoho_client_id || env.ZOHO_CLIENT_ID;
  if (!zohoClientId) return res.status(400).json({ error: 'No Zoho client ID configured' });

  // Generate state for CSRF protection
  const state = `${clientId}:${crypto.randomBytes(16).toString('hex')}`;
  // Store state temporarily (DB or cache, TTL 10 minutes)
  await storeOAuthState(state, { clientId, provider });

  const scopes = provider === 'zoho_crm'
    ? 'ZohoCRM.modules.ALL,ZohoCRM.settings.ALL'
    : 'ZohoCalendar.calendar.ALL';

  const params = new URLSearchParams({
    scope: scopes,
    client_id: zohoClientId,
    redirect_uri: `${env.BASE_URL}/api/oauth/callback`,
    response_type: 'code',
    access_type: 'offline',
    prompt: 'consent',
    state,
  });

  res.redirect(`https://accounts.zoho.com/oauth/v2/auth?${params}`);
});
```

### OAuth Callback Handler
```typescript
// Route: GET /api/oauth/callback
router.get('/callback', async (req, res) => {
  const { code, state, error } = req.query;

  if (error) return res.status(400).send('Authorization denied');

  // Validate state
  const stateData = await getAndDeleteOAuthState(state as string);
  if (!stateData) return res.status(400).send('Invalid or expired state');

  const { clientId, provider } = stateData;
  const config = await clientConfigService.getConfig(clientId);

  // Exchange code for tokens
  const response = await fetch('https://accounts.zoho.com/oauth/v2/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      client_id: config.zoho_client_id || env.ZOHO_CLIENT_ID,
      client_secret: config.zoho_client_secret || env.ZOHO_CLIENT_SECRET,
      redirect_uri: `${env.BASE_URL}/api/oauth/callback`,
      code: code as string,
    }),
  });

  const tokens = await response.json();

  await oauthTokenService.storeTokens(clientId, provider as OAuthProvider, {
    accessToken: tokens.access_token,
    refreshToken: tokens.refresh_token,
    expiresIn: tokens.expires_in,
    scopes: tokens.scope,
    metadata: { api_domain: tokens.api_domain },
  });

  // Redirect admin to success page
  res.redirect(`/admin/clients/${clientId}/setup?oauth=success`);
});
```

### Token Health Check
```typescript
async function checkAllTokenHealth(): Promise<TokenHealthReport[]> {
  const allTokens = await db.select().from(oauthTokens);
  const reports: TokenHealthReport[] = [];

  for (const token of allTokens) {
    const report: TokenHealthReport = {
      clientId: token.clientId,
      provider: token.provider,
      status: 'healthy',
      lastRefresh: token.updatedAt,
    };

    // Check if token is about to expire and refresh preemptively
    if (token.tokenExpiry && token.tokenExpiry.getTime() < Date.now() + 60 * 60 * 1000) {
      try {
        const config = await clientConfigService.getConfig(token.clientId);
        await oauthTokenService.getAccessToken(token.clientId, token.provider as OAuthProvider, {
          clientId: config?.zoho_client_id || env.ZOHO_CLIENT_ID,
          clientSecret: config?.zoho_client_secret || env.ZOHO_CLIENT_SECRET,
        });
        report.status = 'healthy';
      } catch (err) {
        report.status = err.message.includes('invalid_grant') ? 'invalid' : 'refresh_failed';
        report.error = err.message;
      }
    }

    reports.push(report);
  }

  return reports;
}
```

## State of the Art

| Old Approach | Current Approach | Impact |
|--------------|------------------|--------|
| Env var refresh tokens | DB-backed per-client tokens | Already migrated in Phase 5 |
| Single-tenant config | `ClientConfigService` with per-client JSON | Foundation exists |
| No OAuth flow | Only refresh-token exchange | Need to add authorization code flow |
| No monitoring | No token health checks | Need to add health monitoring |

## Open Questions

1. **Zoho OAuth app credentials: per-client or shared?**
   - What we know: `ClientConfig` has optional `zoho_client_id`/`zoho_client_secret` fields, with fallback to env vars
   - Recommendation: Use shared env var credentials for now (single Zoho OAuth app). Per-client app credentials are for future Salesforce/HubSpot extensibility.

2. **OAuth state storage mechanism**
   - What we know: Need short-lived storage for OAuth state parameter (10 min TTL)
   - Recommendation: Use a simple DB table (`oauth_states`) or in-memory Map with TTL. Single-instance deployment makes in-memory acceptable for now, but DB is safer.

3. **Alert delivery mechanism**
   - What we know: `errorMonitorService` exists for error logging. No push notification system.
   - Recommendation: Log token health issues via `errorMonitorService`. Dashboard already shows errors. Future: add email alerts for critical token failures.

## Sources

### Primary (HIGH confidence)
- Codebase analysis: `oauth-token.service.ts`, `oauthTokens.ts` schema, `client-config.service.ts`, `auth.middleware.ts`, `divine.ts` routes, `zoho-crm.service.ts`, `retell.types.ts` (ClientConfigSchema)
- Zoho OAuth documentation (accounts.zoho.com/oauth/v2) - standard OAuth 2.0 authorization code flow

### Secondary (MEDIUM confidence)
- Zoho refresh token invalidation behavior based on training data knowledge of OAuth 2.0 provider patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries already in use, no new dependencies
- Architecture: HIGH - extends existing patterns directly
- Pitfalls: HIGH - derived from codebase analysis of actual current implementation
- Zoho-specific behavior: MEDIUM - OAuth 2.0 standard, Zoho-specific details from training data

**Research date:** 2026-01-27
**Valid until:** 2026-02-27
