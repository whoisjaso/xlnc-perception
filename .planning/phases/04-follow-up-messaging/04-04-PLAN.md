---
phase: 04-follow-up-messaging
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - backend/src/routes/divine.ts
  - src/services/divine.ts
  - components/divine/MessageQueueViewer.tsx
  - src/hooks/useSocketMessages.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard shows real-time message updates via WebSocket"
    - "Messages organized by status tabs (Pending/Sent/Failed/Dead Letter)"
    - "Failed messages prominently displayed at top of dashboard"
    - "Scheduled messages view shows next 24-48 hours of pending reminders"
    - "Full message content visible in expanded view"
  artifacts:
    - path: "components/divine/MessageQueueViewer.tsx"
      provides: "Enhanced message queue dashboard with status tabs and real-time updates"
      contains: "useSocketMessages|dead_letter"
    - path: "src/hooks/useSocketMessages.ts"
      provides: "WebSocket hook for real-time message updates"
      exports: ["useSocketMessages"]
    - path: "backend/src/routes/divine.ts"
      provides: "API endpoints for scheduled messages"
      contains: "scheduled"
  key_links:
    - from: "components/divine/MessageQueueViewer.tsx"
      to: "src/hooks/useSocketMessages.ts"
      via: "hook import and usage"
      pattern: "useSocketMessages"
    - from: "src/hooks/useSocketMessages.ts"
      to: "backend queue-processor Socket.IO events"
      via: "socket.io-client connection"
      pattern: "queue:message"
---

<objective>
Enhance the dashboard MessageQueueViewer with real-time WebSocket updates, status tabs, prominent failed message alerts, and scheduled message view.

Purpose: Per CONTEXT.md, the admin needs full visibility into the messaging system with real-time updates, organized views by status, and prominent failed message display for quick action.

Output: Enhanced dashboard component with WebSocket integration and improved UX for message management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-follow-up-messaging/04-CONTEXT.md
@.planning/phases/04-follow-up-messaging/04-RESEARCH.md
@.planning/phases/04-follow-up-messaging/04-01-SUMMARY.md
@.planning/phases/04-follow-up-messaging/04-02-SUMMARY.md
@components/divine/MessageQueueViewer.tsx
@src/services/divine.ts
@backend/src/routes/divine.ts
@backend/src/services/divine/queue-processor.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Scheduled Messages API Endpoint</name>
  <files>backend/src/routes/divine.ts</files>
  <action>
Add a new endpoint to retrieve scheduled messages (next 24-48 hours):

```typescript
/**
 * GET /divine/queue/scheduled
 * Get scheduled messages for the next N hours (default 48)
 */
router.get('/queue/scheduled', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { clientId, hours = '48' } = req.query;
    const messages = await messageQueueService.getScheduledMessages(
      parseInt(hours as string),
      clientId as string | undefined
    );
    res.json(createTheatricalResponse({ messages, total: messages.length }));
  } catch (error) {
    res.status(500).json(createErrorResponse('Failed to get scheduled messages', 500));
  }
});

/**
 * GET /divine/queue/dead-letter
 * Get dead letter messages
 */
router.get('/queue/dead-letter', authenticateToken, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const { clientId } = req.query;
    const messages = await queueProcessorService.getDeadLetterMessages(clientId as string | undefined);
    res.json(createTheatricalResponse({ messages, total: messages.length }));
  } catch (error) {
    res.status(500).json(createErrorResponse('Failed to get dead letter messages', 500));
  }
});
```

Add messageQueueService import if not already present.

Also add getDeadLetterMessages method to queue-processor.service.ts:

```typescript
async getDeadLetterMessages(clientId?: string): Promise<MessageQueueItem[]> {
  const query = db
    .select()
    .from(messageQueue)
    .where(eq(messageQueue.status, 'dead_letter'))
    .orderBy(desc(messageQueue.deadLetterAt));

  if (clientId) {
    return query.where(
      and(eq(messageQueue.status, 'dead_letter'), eq(messageQueue.clientId, clientId))
    );
  }

  return query;
}
```
  </action>
  <verify>Run `npm run build` - endpoints compile without error.</verify>
  <done>API endpoints for scheduled messages and dead letter messages exist</done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket Hook for Real-time Updates</name>
  <files>src/hooks/useSocketMessages.ts</files>
  <action>
Create a React hook for WebSocket message updates. The backend queue-processor already emits events:
- queue:stats
- queue:message:processing
- queue:message:sent
- queue:message:failed
- queue:message:retry

```typescript
import { useState, useEffect, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';
import { QueueStats, QueueMessage } from '../services/divine';

interface MessageEvent {
  messageId: string;
  channel: 'sms' | 'email';
  recipient: string;
  processingTimeMs?: number;
  error?: string;
  attempts?: number;
  nextRetry?: string;
}

interface UseSocketMessagesReturn {
  stats: QueueStats | null;
  recentEvents: MessageEvent[];
  isConnected: boolean;
  reconnect: () => void;
}

export function useSocketMessages(serverUrl?: string): UseSocketMessagesReturn {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [stats, setStats] = useState<QueueStats | null>(null);
  const [recentEvents, setRecentEvents] = useState<MessageEvent[]>([]);
  const [isConnected, setIsConnected] = useState(false);

  const addEvent = useCallback((event: MessageEvent) => {
    setRecentEvents(prev => [event, ...prev.slice(0, 49)]); // Keep last 50 events
  }, []);

  const connect = useCallback(() => {
    const url = serverUrl || import.meta.env.VITE_API_URL || 'http://localhost:3001';
    const newSocket = io(url, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    newSocket.on('connect', () => {
      console.log('WebSocket connected for message queue');
      setIsConnected(true);
    });

    newSocket.on('disconnect', () => {
      console.log('WebSocket disconnected');
      setIsConnected(false);
    });

    newSocket.on('queue:stats', (data: QueueStats) => {
      setStats(data);
    });

    newSocket.on('queue:message:processing', (data: MessageEvent) => {
      addEvent({ ...data, status: 'processing' } as any);
    });

    newSocket.on('queue:message:sent', (data: MessageEvent) => {
      addEvent({ ...data, status: 'sent' } as any);
    });

    newSocket.on('queue:message:failed', (data: MessageEvent) => {
      addEvent({ ...data, status: 'failed' } as any);
    });

    newSocket.on('queue:message:retry', (data: MessageEvent) => {
      addEvent({ ...data, status: 'retry' } as any);
    });

    setSocket(newSocket);

    return newSocket;
  }, [serverUrl, addEvent]);

  useEffect(() => {
    const sock = connect();
    return () => {
      sock.disconnect();
    };
  }, [connect]);

  const reconnect = useCallback(() => {
    if (socket) {
      socket.disconnect();
    }
    connect();
  }, [socket, connect]);

  return { stats, recentEvents, isConnected, reconnect };
}

export default useSocketMessages;
```
  </action>
  <verify>TypeScript compiles. Hook exports useSocketMessages.</verify>
  <done>useSocketMessages hook created with WebSocket connection and event handling</done>
</task>

<task type="auto">
  <name>Task 3: Enhance MessageQueueViewer with Real-time and Tabs</name>
  <files>components/divine/MessageQueueViewer.tsx</files>
  <action>
Enhance the existing MessageQueueViewer component:

1. Import and use the useSocketMessages hook
2. Add status tabs: All | Pending | Sent | Failed | Dead Letter | Scheduled
3. Add prominent failed/dead letter alert banner at top
4. Show real-time event feed in sidebar
5. Improve message content visibility (show full body on expand)
6. Add scheduled messages view

Update the component:

```typescript
// Add imports
import { useSocketMessages } from '../../src/hooks/useSocketMessages';
import { AlertCircle, Calendar, Inbox } from 'lucide-react';

// Add new state for tabs and dead letter
const [activeTab, setActiveTab] = useState<'all' | 'pending' | 'sent' | 'failed' | 'dead_letter' | 'scheduled'>('all');
const [deadLetterMessages, setDeadLetterMessages] = useState<QueueMessage[]>([]);
const [scheduledMessages, setScheduledMessages] = useState<QueueMessage[]>([]);

// Use the WebSocket hook
const { stats: wsStats, recentEvents, isConnected, reconnect } = useSocketMessages();

// Merge WebSocket stats with polled stats
const displayStats = wsStats || stats;

// Load dead letter and scheduled messages
const loadData = async () => {
  try {
    setIsLoading(true);
    const [statsData, messagesData, failedData, deadLetterData, scheduledData] = await Promise.all([
      divineApi.getQueueStats(),
      divineApi.getQueueMessages({ limit: 50 }),
      divineApi.getFailedMessages(),
      divineApi.getDeadLetterMessages?.() || Promise.resolve({ messages: [] }),
      divineApi.getScheduledMessages?.({ hours: 48 }) || Promise.resolve({ messages: [] }),
    ]);
    setStats(statsData.stats);
    setMessages(messagesData.messages);
    setFailedMessages(failedData.messages);
    setDeadLetterMessages(deadLetterData.messages || []);
    setScheduledMessages(scheduledData.messages || []);
  } catch (error) {
    console.error('Failed to load queue data:', error);
  } finally {
    setIsLoading(false);
  }
};

// Add prominent failed/dead letter banner
{(failedMessages.length > 0 || deadLetterMessages.length > 0) && (
  <div className="bg-red-500/10 border border-red-500/30 p-4 mb-6 flex items-center justify-between">
    <div className="flex items-center gap-3">
      <AlertCircle size={20} className="text-red-500" />
      <div>
        <div className="text-sm font-bold text-red-500">
          {failedMessages.length + deadLetterMessages.length} Message(s) Need Attention
        </div>
        <div className="text-[10px] text-red-400">
          {failedMessages.length} failed, {deadLetterMessages.length} in dead letter queue
        </div>
      </div>
    </div>
    <button
      onClick={() => setActiveTab('failed')}
      className="text-[10px] font-bold uppercase px-3 py-1.5 border border-red-500/30 text-red-500 hover:bg-red-500/10"
    >
      View Failed
    </button>
  </div>
)}

// Enhanced tabs with more options
const tabs = [
  { id: 'all', label: 'All', count: messages.length },
  { id: 'pending', label: 'Pending', count: displayStats?.pending || 0 },
  { id: 'sent', label: 'Sent', count: displayStats?.sent || 0 },
  { id: 'failed', label: 'Failed', count: failedMessages.length, color: 'red' },
  { id: 'dead_letter', label: 'Dead Letter', count: deadLetterMessages.length, color: 'red' },
  { id: 'scheduled', label: 'Scheduled', count: scheduledMessages.length, icon: Calendar },
];

// WebSocket connection indicator
<div className="flex items-center gap-2 text-[10px]">
  <span className={`w-2 h-2 rounded-full ${isConnected ? 'bg-emerald-500' : 'bg-red-500'}`} />
  <span className="text-gray-500">{isConnected ? 'Live' : 'Disconnected'}</span>
  {!isConnected && (
    <button onClick={reconnect} className="text-xlnc-gold hover:underline">
      Reconnect
    </button>
  )}
</div>

// Scheduled messages view
{activeTab === 'scheduled' && (
  <div className="space-y-2">
    <div className="text-[10px] text-gray-500 uppercase mb-2">
      Scheduled for next 48 hours
    </div>
    {scheduledMessages.map(message => (
      // Render scheduled message with scheduledFor time prominently displayed
    ))}
  </div>
)}

// Add real-time event feed sidebar (optional, if space allows)
{recentEvents.length > 0 && (
  <div className="bg-black/30 border border-white/5 p-3 mt-4">
    <div className="text-[9px] text-gray-500 uppercase mb-2">Recent Activity (Live)</div>
    <div className="space-y-1 max-h-32 overflow-y-auto">
      {recentEvents.slice(0, 10).map((event, idx) => (
        <div key={idx} className="text-[10px] text-gray-400 flex items-center gap-2">
          <span className={`w-1.5 h-1.5 rounded-full ${
            event.status === 'sent' ? 'bg-emerald-500' :
            event.status === 'failed' ? 'bg-red-500' :
            'bg-yellow-500'
          }`} />
          <span className="truncate">{event.channel} to {event.recipient.slice(-4)} - {event.status}</span>
        </div>
      ))}
    </div>
  </div>
)}
```

Full code should integrate these pieces while preserving existing functionality.
  </action>
  <verify>Component renders without errors. Tabs switch correctly. WebSocket shows connected.</verify>
  <done>MessageQueueViewer has status tabs, prominent failed alert, WebSocket integration, scheduled view</done>
</task>

</tasks>

<verification>
1. Run `npm run build` in backend - API endpoints compile
2. Run `npm run build` in frontend - components compile
3. Start dev server and verify WebSocket connects
4. Verify tabs switch and show correct data
5. Verify failed messages banner appears when there are failures
</verification>

<success_criteria>
- API endpoint /divine/queue/scheduled returns scheduled messages
- API endpoint /divine/queue/dead-letter returns dead letter messages
- useSocketMessages hook connects to WebSocket and receives events
- MessageQueueViewer shows status tabs (All/Pending/Sent/Failed/Dead Letter/Scheduled)
- Failed messages banner prominently displayed at top
- Real-time updates appear without manual refresh
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-follow-up-messaging/04-04-SUMMARY.md`
</output>
