---
phase: 03-webhook-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/core/router.ts
  - backend/src/services/memory/customer.ts
autonomous: true

must_haves:
  truths:
    - "Returning customers are greeted by name with context"
    - "Customer call history is loaded for context_request"
    - "Context includes last call summary and PRISM profile"
  artifacts:
    - path: "backend/src/core/router.ts"
      provides: "CentralRouter using contextBuilderService"
      contains: "contextBuilderService"
    - path: "backend/src/services/memory/customer.ts"
      provides: "CustomerMemory delegating to services"
      min_lines: 20
  key_links:
    - from: "backend/src/core/router.ts"
      to: "backend/src/services/divine/context-builder.service.ts"
      via: "import and method call"
      pattern: "contextBuilderService\\.buildContext"
---

<objective>
Fix CustomerMemory stub to enable proper customer context in context_request responses.

Purpose: The CentralRouter.handleContextRequest method uses CustomerMemory which returns empty data. This breaks the REQ-003 requirement that returning customers be greeted by name with full context. The contextBuilderService already works correctly and should be used instead.

Output: CentralRouter returns comprehensive customer context including name, call history, PRISM profile, and conversation notes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-webhook-processing/03-RESEARCH.md

# Key source files
@backend/src/core/router.ts
@backend/src/services/memory/customer.ts
@backend/src/services/divine/context-builder.service.ts
@backend/src/services/divine/customer.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace CustomerMemory with contextBuilderService in CentralRouter</name>
  <files>backend/src/core/router.ts</files>
  <action>
Update CentralRouter.handleContextRequest to use contextBuilderService instead of the broken CustomerMemory class:

1. Import contextBuilderService at top of file:
   ```typescript
   import { contextBuilderService } from '../services/divine/context-builder.service';
   ```

2. In handleContextRequest method, replace the customer memory section (lines 111-122) with:
   ```typescript
   // Load customer context using contextBuilderService
   try {
     const customerContext = await contextBuilderService.buildContext(
       call.from_number,
       config
     );

     // Merge customer context into response
     Object.assign(response, customerContext);

     // Set returning customer flag based on context
     if (customerContext.is_returning_customer === 'true') {
       response.returning_customer = true;
       response.customer_name = customerContext.customer_name;
       response.previous_interactions = parseInt(customerContext.call_count) || 0;
       response.last_call_summary = customerContext.conversation_notes;
     } else {
       response.returning_customer = false;
     }
   } catch (error) {
     logger.error({ error, phone: call.from_number }, 'Failed to build customer context');
     response.returning_customer = false;
   }
   ```

3. Remove the CustomerMemory import from the top of the file (line 4).

4. Remove the customerMemory property from the constructor and class field (lines 11, 16).

5. Update handleCallEnded to also use contextBuilderService instead of customerMemory.getHistory (line 138):
   ```typescript
   // Get customer history for analysis
   const customerHistoryResult = await contextBuilderService.buildFullCustomerContext(
     call.from_number,
     config
   );
   const customerHistory = customerHistoryResult.customerContext;
   ```

Do NOT change the calendar availability logic - that section works correctly.
  </action>
  <verify>
Run TypeScript compiler to verify no type errors:
```bash
cd backend && npx tsc --noEmit
```
  </verify>
  <done>CentralRouter.handleContextRequest uses contextBuilderService and returns customer name, call count, and conversation notes for returning customers.</done>
</task>

<task type="auto">
  <name>Task 2: Update CustomerMemory to delegate to services</name>
  <files>backend/src/services/memory/customer.ts</files>
  <action>
Replace the stub CustomerMemory class with a proper implementation that delegates to existing services. This ensures any other code using CustomerMemory still works:

```typescript
import { customerService } from '../divine/customer.service';
import { conversationService } from '../divine/conversation.service';
import { logger } from '../../utils/logger';

export interface CustomerHistoryEntry {
  callId: string;
  summary: string | null;
  intent: string | null;
  sentiment: string | null;
  createdAt: Date | null;
}

export class CustomerMemory {
  /**
   * Get customer call history by phone number.
   * NOTE: This requires clientId for proper lookup. Without it,
   * we cannot reliably find the customer. Consider using
   * contextBuilderService.buildContext() instead.
   */
  async getHistory(phoneNumber: string, clientId?: string): Promise<CustomerHistoryEntry[]> {
    if (!clientId) {
      logger.warn(
        { phone: phoneNumber.slice(-4) },
        'CustomerMemory.getHistory called without clientId - cannot lookup customer'
      );
      return [];
    }

    try {
      const customer = await customerService.getByPhone(clientId, phoneNumber);

      if (!customer) {
        logger.debug({ phone: phoneNumber.slice(-4) }, 'No customer found for phone');
        return [];
      }

      const conversations = await conversationService.getRecentByCustomer(customer.id, 10);

      return conversations.map(conv => ({
        callId: conv.callId,
        summary: conv.summary,
        intent: conv.intent,
        sentiment: conv.sentiment,
        createdAt: conv.createdAt,
      }));
    } catch (error) {
      logger.error({ error, phone: phoneNumber.slice(-4) }, 'Failed to get customer history');
      return [];
    }
  }

  /**
   * Get full customer context. Delegates to customerService.
   */
  async getContext(customerId: string) {
    return customerService.getContext(customerId);
  }
}
```

This implementation:
- Adds proper imports for existing services
- Requires clientId for proper customer lookup
- Logs warnings when called without clientId (helps identify other callers)
- Returns properly typed history entries
- Gracefully handles errors
  </action>
  <verify>
Run TypeScript compiler:
```bash
cd backend && npx tsc --noEmit
```
  </verify>
  <done>CustomerMemory class delegates to customerService and conversationService, returning real customer history data.</done>
</task>

<task type="auto">
  <name>Task 3: Verify context_request returns customer data</name>
  <files>N/A - verification task</files>
  <action>
Create a test script to verify context_request handling works correctly:

1. Create file `backend/scripts/test-context-request.ts`:
```typescript
/**
 * Test script to verify context_request handling returns customer data
 */
import { CentralRouter } from '../src/core/router';
import { clientConfigService } from '../src/services/divine/client-config.service';
import { customerService } from '../src/services/divine/customer.service';
import { conversationService } from '../src/services/divine/conversation.service';

async function testContextRequest() {
  console.log('=== Testing context_request handling ===\n');

  // Load Smart Tax Nation config
  const config = await clientConfigService.getConfig('smart-tax-nation');
  if (!config) {
    console.error('ERROR: Could not load smart-tax-nation config');
    process.exit(1);
  }
  console.log('Loaded config for:', config.business_name);

  // Create a test customer if one doesn't exist
  const testPhone = '+15551234567';
  let customer = await customerService.getByPhone(config.client_id, testPhone);

  if (!customer) {
    console.log('Creating test customer...');
    customer = await customerService.getOrCreate(config.client_id, testPhone, {
      name: 'Test Customer',
      email: 'test@example.com',
    });
  }
  console.log('Test customer ID:', customer.id);

  // Create a test conversation if needed
  const conversations = await conversationService.getRecentByCustomer(customer.id, 1);
  if (conversations.length === 0) {
    console.log('Creating test conversation...');
    await conversationService.create({
      customerId: customer.id,
      clientId: config.client_id,
      callId: 'test-call-' + Date.now(),
      direction: 'inbound',
      status: 'completed',
      summary: 'Discussed tax filing options',
      intent: 'tax_filing_inquiry',
    });
  }

  // Increment call count
  await customerService.incrementCallCount(customer.id);

  // Test context_request
  const router = new CentralRouter();
  const mockEvent = {
    event_id: 'test-event-' + Date.now(),
    event_type: 'context_request' as const,
    call: {
      call_id: 'test-call-' + Date.now(),
      from_number: testPhone,
      to_number: '+18001234567',
      agent_id: config.retell_agent_id || 'test-agent',
      direction: 'inbound',
      call_status: 'in_progress',
      transcript: '',
      duration_seconds: 0,
    },
    timestamp: new Date().toISOString(),
  };

  console.log('\nSending context_request...');
  const decision = await router.route(mockEvent, config as any);

  console.log('\n=== RESULT ===');
  console.log('Action:', decision.action);

  if (decision.action === 'respond_with_context' && decision.response) {
    console.log('\nContext Response:');
    console.log(JSON.stringify(decision.response, null, 2));

    // Verify key fields
    const response = decision.response;
    const checks = [
      { field: 'customer_name', expected: 'Test Customer', actual: response.customer_name },
      { field: 'is_returning_customer', expected: 'true', actual: response.is_returning_customer },
      { field: 'returning_customer', expected: true, actual: response.returning_customer },
    ];

    console.log('\n=== VERIFICATION ===');
    let allPassed = true;
    for (const check of checks) {
      const passed = String(check.actual) === String(check.expected);
      console.log(`${passed ? 'PASS' : 'FAIL'}: ${check.field} = ${check.actual} (expected: ${check.expected})`);
      if (!passed) allPassed = false;
    }

    if (allPassed) {
      console.log('\nSUCCESS: context_request returns customer data correctly');
    } else {
      console.log('\nFAILURE: Some checks failed');
      process.exit(1);
    }
  } else {
    console.error('ERROR: Expected respond_with_context action');
    process.exit(1);
  }
}

testContextRequest().catch(err => {
  console.error('Test failed:', err);
  process.exit(1);
});
```

2. Run the test:
```bash
cd backend && npx ts-node scripts/test-context-request.ts
```
  </action>
  <verify>
Test script outputs:
- "PASS: customer_name = Test Customer"
- "PASS: is_returning_customer = true"
- "SUCCESS: context_request returns customer data correctly"
  </verify>
  <done>context_request handling verified to return customer name and context for returning customers.</done>
</task>

</tasks>

<verification>
Phase 03 Plan 01 verification:
1. TypeScript compiles without errors: `cd backend && npx tsc --noEmit`
2. Test script passes: `cd backend && npx ts-node scripts/test-context-request.ts`
3. Grep confirms contextBuilderService is used: `grep -r "contextBuilderService" backend/src/core/router.ts`
</verification>

<success_criteria>
- CentralRouter imports and uses contextBuilderService instead of CustomerMemory
- context_request returns customer_name for returning customers
- context_request returns call history context (conversation_notes)
- Test script passes all verification checks
</success_criteria>

<output>
After completion, create `.planning/phases/03-webhook-processing/03-01-SUMMARY.md`
</output>
