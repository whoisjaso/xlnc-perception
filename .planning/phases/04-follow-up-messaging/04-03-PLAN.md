---
phase: 04-follow-up-messaging
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/services/divine/post-call-processor.ts
  - backend/src/services/divine/nurture-sequence.service.ts
  - backend/src/services/divine/index.ts
autonomous: true

must_haves:
  truths:
    - "Confirmation SMS sent immediately after successful booking"
    - "Non-bookers receive nurture sequence on Day 1 and Day 4"
    - "Marketing/nurture messages only sent during business hours"
    - "Confirmations send 24/7 regardless of business hours"
    - "Messages include booking link and portal link per CONTEXT.md"
  artifacts:
    - path: "backend/src/services/divine/post-call-processor.ts"
      provides: "Enhanced post-call processing with intent-based routing"
      contains: "reminder_24h|confirmation|nurture"
    - path: "backend/src/services/divine/nurture-sequence.service.ts"
      provides: "Nurture sequence scheduling for non-bookers"
      exports: ["nurtureSequenceService"]
  key_links:
    - from: "backend/src/services/divine/post-call-processor.ts"
      to: "backend/src/services/divine/reminder-scheduler.service.ts"
      via: "scheduleAppointmentReminders call"
      pattern: "reminderSchedulerService"
    - from: "backend/src/services/divine/nurture-sequence.service.ts"
      to: "backend/src/utils/business-hours.ts"
      via: "isWithinBusinessHours check"
      pattern: "isWithinBusinessHours"
---

<objective>
Enhance post-call processing with intent-based message routing and implement nurture sequences for non-bookers.

Purpose: Per CONTEXT.md, different call outcomes trigger different follow-up patterns. Bookings trigger immediate confirmation + reminders. Non-bookers get nurture sequences on Day 1 and Day 4. Marketing messages respect business hours.

Output: Enhanced post-call processor with booking detection and nurture sequence service.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-follow-up-messaging/04-CONTEXT.md
@.planning/phases/04-follow-up-messaging/04-RESEARCH.md
@.planning/phases/04-follow-up-messaging/04-01-SUMMARY.md
@backend/src/services/divine/post-call-processor.ts
@backend/src/services/divine/message-queue.service.ts
@backend/src/services/divine/followup-writer.service.ts
@backend/src/utils/business-hours.ts
@backend/config/clients/smart-tax-nation.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Nurture Sequence Service</name>
  <files>backend/src/services/divine/nurture-sequence.service.ts</files>
  <action>
Create a service to handle nurture sequences for non-booking callers.

Per CONTEXT.md:
- Nurture sequence: 1-2 follow-up attempts for non-bookers
- Nurture spacing: Day 1 (first follow-up), Day 4 (second follow-up)
- Marketing messages only during business hours

```typescript
import { messageQueueService } from './message-queue.service';
import { followUpWriterService, FollowUpContext } from './followup-writer.service';
import { clientConfigService } from './client-config.service';
import { isWithinBusinessHours, getNextBusinessHour } from '../../utils/business-hours';
import { logger } from '../../utils/logger';
import { addDays, addHours } from 'date-fns';

interface NurtureContext {
  clientId: string;
  customerId: string;
  customerPhone: string;
  customerEmail?: string;
  customerName?: string;
  callSummary: string;
  intent: string;
  businessName: string;
  dominantNeed?: string;
}

export class NurtureSequenceService {
  private readonly BOOKING_LINK = 'https://smarttaxnation.com/book';
  private readonly PORTAL_LINK = 'https://smarttaxnation.com/portal';

  /**
   * Schedule nurture sequence for a non-booking caller
   * Day 1: First follow-up (24h after call)
   * Day 4: Second follow-up (96h after call)
   */
  async scheduleNurtureSequence(context: NurtureContext): Promise<void> {
    const { clientId, customerId, customerPhone, customerEmail, customerName, callSummary, businessName, intent, dominantNeed } = context;

    // Get client config for business hours
    const config = await clientConfigService.getConfig(clientId);
    if (!config) {
      logger.warn({ clientId }, 'No client config found for nurture sequence');
      return;
    }

    const timezone = config.timezone || 'America/New_York';
    const businessHours = config.business_hours;

    // Calculate nurture send times (respecting business hours)
    const now = new Date();
    let day1Send = addDays(now, 1); // 24 hours later
    let day4Send = addDays(now, 4); // 96 hours later

    // If day1Send is outside business hours, push to next business hour
    if (businessHours && !isWithinBusinessHours(day1Send, businessHours, timezone)) {
      day1Send = getNextBusinessHour(day1Send, businessHours, timezone);
    }

    if (businessHours && !isWithinBusinessHours(day4Send, businessHours, timezone)) {
      day4Send = getNextBusinessHour(day4Send, businessHours, timezone);
    }

    // Build context for AI-generated content
    const followUpContext: FollowUpContext = {
      customerName,
      customerPhone,
      businessName,
      intent: intent as any,
      summary: callSummary,
      appointmentBooked: false,
      dominantNeed: dominantNeed as any,
    };

    // Day 1 SMS - Reference the original call
    const day1SMS = this.buildNurtureSMS(customerName, businessName, 'day1');
    await messageQueueService.enqueueSMS(clientId, customerPhone, day1SMS, {
      customerId,
      scheduledFor: day1Send,
      messageType: 'nurture_day1',
      metadata: { intent, originalCallDate: now.toISOString() }
    });
    logger.info({ clientId, customerId, scheduledFor: day1Send }, 'Day 1 nurture SMS scheduled');

    // Day 4 SMS - Second follow-up
    const day4SMS = this.buildNurtureSMS(customerName, businessName, 'day4');
    await messageQueueService.enqueueSMS(clientId, customerPhone, day4SMS, {
      customerId,
      scheduledFor: day4Send,
      messageType: 'nurture_day4',
      metadata: { intent, originalCallDate: now.toISOString() }
    });
    logger.info({ clientId, customerId, scheduledFor: day4Send }, 'Day 4 nurture SMS scheduled');

    // Email nurture if email available
    if (customerEmail) {
      const day1Email = this.buildNurtureEmail(customerName, businessName, callSummary, 'day1');
      await messageQueueService.enqueueEmail(clientId, customerEmail, day1Email.subject, day1Email.body, {
        customerId,
        scheduledFor: day1Send,
        messageType: 'nurture_day1',
        metadata: { intent, originalCallDate: now.toISOString() }
      });

      const day4Email = this.buildNurtureEmail(customerName, businessName, callSummary, 'day4');
      await messageQueueService.enqueueEmail(clientId, customerEmail, day4Email.subject, day4Email.body, {
        customerId,
        scheduledFor: day4Send,
        messageType: 'nurture_day4',
        metadata: { intent, originalCallDate: now.toISOString() }
      });
    }
  }

  private buildNurtureSMS(name: string | undefined, business: string, day: 'day1' | 'day4'): string {
    const greeting = name ? `Hi ${name}! ` : '';

    if (day === 'day1') {
      return `${greeting}Following up on our chat about your tax needs. Ready to book your consultation with ${business}? ${this.BOOKING_LINK}`;
    } else {
      return `${greeting}Still thinking about ${business}? We'd love to help you with your tax questions. Book anytime: ${this.BOOKING_LINK}`;
    }
  }

  private buildNurtureEmail(
    name: string | undefined,
    business: string,
    callSummary: string,
    day: 'day1' | 'day4'
  ): { subject: string; body: string } {
    const greeting = name ? `Hi ${name}` : 'Hi there';

    if (day === 'day1') {
      return {
        subject: `Following up on our conversation - ${business}`,
        body: `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .btn { display: inline-block; padding: 12px 24px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px; }
    .footer { margin-top: 30px; color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <p>${greeting},</p>

    <p>It was great chatting with you! I wanted to follow up on our conversation about your tax needs.</p>

    <p>${callSummary ? `As we discussed: ${callSummary}` : 'We\'d love to help you with your tax questions and planning.'}</p>

    <p>When you're ready to take the next step, we're here to help!</p>

    <p>
      <a href="${this.BOOKING_LINK}" class="btn">Schedule Your Consultation</a>
    </p>

    <p>You can also use our <a href="${this.PORTAL_LINK}">secure portal</a> to upload any documents you'd like us to review.</p>

    <div class="footer">
      <p>Best regards,<br>The ${business} Team</p>
    </div>
  </div>
</body>
</html>`
      };
    } else {
      return {
        subject: `We're still here to help - ${business}`,
        body: `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .btn { display: inline-block; padding: 12px 24px; background-color: #28a745; color: white; text-decoration: none; border-radius: 4px; }
    .footer { margin-top: 30px; color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <p>${greeting},</p>

    <p>I hope you're doing well! I wanted to reach out one more time about your tax consultation.</p>

    <p>Our team at ${business} is ready to help you navigate your tax questions and find the best solutions for your situation.</p>

    <p>
      <a href="${this.BOOKING_LINK}" class="btn">Book Your Free Consultation</a>
    </p>

    <p>If you have any questions before booking, feel free to give us a call or reply to this email.</p>

    <div class="footer">
      <p>Looking forward to hearing from you,<br>The ${business} Team</p>
    </div>
  </div>
</body>
</html>`
      };
    }
  }
}

export const nurtureSequenceService = new NurtureSequenceService();
```
  </action>
  <verify>TypeScript compiles. Service exports nurtureSequenceService.</verify>
  <done>nurture-sequence.service.ts created with scheduleNurtureSequence method that respects business hours</done>
</task>

<task type="auto">
  <name>Task 2: Enhance Post-Call Processor with Booking Detection</name>
  <files>backend/src/services/divine/post-call-processor.ts</files>
  <action>
Enhance the PostCallProcessor to:
1. Import reminderSchedulerService and nurtureSequenceService
2. Detect if appointment was booked during call (from conversation/entities)
3. Route to confirmation + reminders for bookings
4. Route to nurture sequence for non-bookings

Update process() method flow:
1. After intent classification, check if appointmentBooked in entities or summary
2. If booked:
   - Send immediate confirmation SMS (24/7, no business hours check)
   - Schedule appointment reminders via reminderSchedulerService
3. If not booked but is a booking-intent call:
   - Schedule nurture sequence via nurtureSequenceService

Update queueFollowUp method to:
- Accept appointmentDetails parameter
- Use messageType 'confirmation' for booking confirmations
- Include booking link and portal link in messages

```typescript
// Add to imports
import { reminderSchedulerService } from './reminder-scheduler.service';
import { nurtureSequenceService } from './nurture-sequence.service';

// In process() after classification:
const appointmentBooked = entities['appointment_time'] ||
  data.summary?.toLowerCase().includes('appointment booked') ||
  data.summary?.toLowerCase().includes('booked for');

if (appointmentBooked && entities['appointment_time']) {
  // Parse appointment time and schedule reminders
  const appointmentTime = this.parseAppointmentTime(entities['appointment_time']);
  if (appointmentTime) {
    await reminderSchedulerService.scheduleAppointmentReminders({
      clientId: data.clientId,
      customerId: customer.id,
      customerPhone: data.phone,
      customerEmail: customer.email || undefined,
      customerName: customer.name || undefined,
      appointmentTime,
      appointmentType: entities['appointment_type'],
      businessName: data.businessName || 'Our team',
    });

    // Send immediate confirmation SMS (no business hours restriction)
    await this.sendBookingConfirmation(data, customer);
  }
} else if (this.shouldSendNurture(intent)) {
  // Non-booking, potentially interested caller
  await nurtureSequenceService.scheduleNurtureSequence({
    clientId: data.clientId,
    customerId: customer.id,
    customerPhone: data.phone,
    customerEmail: customer.email || undefined,
    customerName: customer.name || undefined,
    callSummary: data.summary || '',
    intent,
    businessName: data.businessName || 'Our team',
    dominantNeed: prismAnalysis.dominantNeeds?.[0],
  });
}

// Add helper methods
private shouldSendNurture(intent: string): boolean {
  const nurtureIntents = ['booking_request', 'pricing_question', 'information_inquiry', 'sales_opportunity'];
  return nurtureIntents.includes(intent);
}

private async sendBookingConfirmation(data: PostCallData, customer: Customer): Promise<void> {
  const bookingLink = 'https://smarttaxnation.com/book';
  const portalLink = 'https://smarttaxnation.com/portal';

  const greeting = customer.name ? `Hi ${customer.name}! ` : '';
  const confirmationSMS = `${greeting}Your appointment with ${data.businessName || 'us'} is confirmed! Need to reschedule? ${bookingLink}. Upload docs: ${portalLink}`;

  await messageQueueService.enqueueSMS(data.clientId, data.phone, confirmationSMS, {
    customerId: customer.id,
    messageType: 'confirmation',
    metadata: { callId: data.callId, type: 'booking_confirmation' }
  });
}

private parseAppointmentTime(timeString: string): Date | null {
  // Try to parse various formats
  const parsed = new Date(timeString);
  if (!isNaN(parsed.getTime())) return parsed;
  // Could add more parsing logic for natural language dates
  return null;
}
```

Keep the existing follow-up logic as fallback for non-booking, non-nurture calls.
  </action>
  <verify>TypeScript compiles. Post-call processor imports and uses reminder and nurture services.</verify>
  <done>post-call-processor.ts detects bookings, schedules reminders for bookings, nurture for non-bookings</done>
</task>

<task type="auto">
  <name>Task 3: Export Nurture Sequence from Divine Services Index</name>
  <files>backend/src/services/divine/index.ts</files>
  <action>
Add export for the nurture sequence service:

```typescript
export { nurtureSequenceService } from './nurture-sequence.service';
```
  </action>
  <verify>Import from divine services index works without error.</verify>
  <done>nurtureSequenceService exported from divine services index</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should compile without errors
2. Check post-call-processor.ts imports and uses reminder and nurture services
3. Verify nurture sequence respects business hours via isWithinBusinessHours
4. Verify booking confirmation sends immediately (no business hours check)
</verification>

<success_criteria>
- nurture-sequence.service.ts schedules Day 1 and Day 4 follow-ups
- Nurture messages scheduled for next business hour if outside hours
- post-call-processor.ts detects bookings and routes appropriately
- Booking confirmations send immediately (24/7)
- All messages include booking link and portal link
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-follow-up-messaging/04-03-SUMMARY.md`
</output>
