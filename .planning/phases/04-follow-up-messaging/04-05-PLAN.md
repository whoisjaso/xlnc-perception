---
phase: 04-follow-up-messaging
plan: 05
type: execute
wave: 3
depends_on: ["04-01", "04-04"]
files_modified:
  - backend/src/routes/divine.ts
  - backend/src/services/divine/queue-processor.service.ts
  - src/services/divine.ts
  - components/divine/MessageComposer.tsx
  - components/divine/MessageQueueViewer.tsx
  - components/divine/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can compose and send ad-hoc SMS/email from dashboard"
    - "Admin can edit message content before retrying failed message"
    - "Manual messages tracked with messageType 'manual'"
    - "Edited retry preserves original message metadata"
  artifacts:
    - path: "components/divine/MessageComposer.tsx"
      provides: "Message composition modal for ad-hoc sending"
      exports: ["MessageComposer"]
    - path: "backend/src/routes/divine.ts"
      provides: "API endpoints for manual message and edit-retry"
      contains: "manual|edit"
    - path: "backend/src/services/divine/queue-processor.service.ts"
      provides: "Edit before retry functionality"
      contains: "retryMessageWithEdit"
  key_links:
    - from: "components/divine/MessageComposer.tsx"
      to: "backend POST /divine/queue/manual"
      via: "API call to send manual message"
      pattern: "queue/manual"
    - from: "components/divine/MessageQueueViewer.tsx"
      to: "components/divine/MessageComposer.tsx"
      via: "opens composer for edit-retry"
      pattern: "MessageComposer"
---

<objective>
Add manual message composition and edit-before-retry functionality to the dashboard.

Purpose: Per CONTEXT.md, admins need the ability to compose and send ad-hoc SMS/email from the dashboard, and edit message content before retrying failed messages. This gives admins full control over the messaging flow.

Output: Message composer component and edit-retry API endpoints with dashboard integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-follow-up-messaging/04-CONTEXT.md
@.planning/phases/04-follow-up-messaging/04-RESEARCH.md
@.planning/phases/04-follow-up-messaging/04-01-SUMMARY.md
@.planning/phases/04-follow-up-messaging/04-04-SUMMARY.md
@components/divine/MessageQueueViewer.tsx
@backend/src/routes/divine.ts
@backend/src/services/divine/queue-processor.service.ts
@src/services/divine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Manual Message and Edit-Retry API Endpoints</name>
  <files>backend/src/routes/divine.ts, backend/src/services/divine/queue-processor.service.ts</files>
  <action>
Add API endpoints for manual message sending and edit-retry.

In divine.ts routes:

```typescript
/**
 * POST /divine/queue/manual
 * Send a manual ad-hoc message
 */
router.post('/queue/manual', authenticateToken, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const { clientId, channel, recipient, subject, body, scheduledFor } = req.body;

    if (!clientId || !channel || !recipient || !body) {
      return res.status(400).json(createErrorResponse('Missing required fields: clientId, channel, recipient, body', 400));
    }

    if (channel !== 'sms' && channel !== 'email') {
      return res.status(400).json(createErrorResponse('Channel must be sms or email', 400));
    }

    let message;
    if (channel === 'sms') {
      message = await messageQueueService.enqueueSMS(clientId, recipient, body, {
        scheduledFor: scheduledFor ? new Date(scheduledFor) : new Date(),
        messageType: 'manual',
        metadata: { sentBy: req.user?.email, manual: true }
      });
    } else {
      if (!subject) {
        return res.status(400).json(createErrorResponse('Subject required for email', 400));
      }
      message = await messageQueueService.enqueueEmail(clientId, recipient, subject, body, {
        scheduledFor: scheduledFor ? new Date(scheduledFor) : new Date(),
        messageType: 'manual',
        metadata: { sentBy: req.user?.email, manual: true }
      });
    }

    logger.info({ messageId: message.id, channel, recipient: recipient.slice(-4) }, 'Manual message queued');

    res.status(201).json(createTheatricalResponse({ message, queued: true }));
  } catch (error) {
    logger.error({ error }, 'Failed to queue manual message');
    res.status(500).json(createErrorResponse('Failed to queue message', 500));
  }
});

/**
 * POST /divine/queue/retry/:messageId/edit
 * Retry a failed message with edited content
 */
router.post('/queue/retry/:messageId/edit', authenticateToken, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const { messageId } = req.params;
    const { body, subject } = req.body;

    if (!body) {
      return res.status(400).json(createErrorResponse('Body is required', 400));
    }

    const success = await queueProcessorService.retryMessageWithEdit(messageId, {
      body,
      subject,
      editedBy: req.user?.email
    });

    if (!success) {
      return res.status(404).json(createErrorResponse('Message not found or not retryable', 404));
    }

    res.json(createTheatricalResponse({ retried: true, edited: true }));
  } catch (error) {
    logger.error({ error }, 'Failed to retry message with edit');
    res.status(500).json(createErrorResponse('Failed to retry message', 500));
  }
});
```

In queue-processor.service.ts, add the retryMessageWithEdit method:

```typescript
async retryMessageWithEdit(
  messageId: string,
  edits: { body: string; subject?: string; editedBy?: string }
): Promise<boolean> {
  const [message] = await db
    .select()
    .from(messageQueue)
    .where(eq(messageQueue.id, messageId))
    .limit(1);

  if (!message || (message.status !== 'failed' && message.status !== 'dead_letter')) {
    return false;
  }

  // Update message with new content and reset for retry
  await db
    .update(messageQueue)
    .set({
      body: edits.body,
      subject: edits.subject || message.subject,
      status: 'pending',
      attempts: 0,
      scheduledFor: new Date(),
      lastError: null,
      metadata: {
        ...message.metadata as object,
        editedAt: new Date().toISOString(),
        editedBy: edits.editedBy,
        originalBody: message.body,
      }
    })
    .where(eq(messageQueue.id, messageId));

  logger.info({ messageId, editedBy: edits.editedBy }, 'Message edited and queued for retry');

  // Trigger immediate processing
  this.processQueue();

  return true;
}
```

Add messageQueueService import to divine.ts if not present.
  </action>
  <verify>Run `npm run build` - endpoints compile without error.</verify>
  <done>API endpoints for manual message and edit-retry exist and work</done>
</task>

<task type="auto">
  <name>Task 2: Create MessageComposer Component</name>
  <files>components/divine/MessageComposer.tsx, components/divine/index.ts</files>
  <action>
Create a modal component for composing ad-hoc messages or editing before retry.

```typescript
// components/divine/MessageComposer.tsx
import React, { useState, useEffect } from 'react';
import {
  X,
  Send,
  MessageSquare,
  Mail,
  Loader,
  AlertCircle
} from 'lucide-react';
import { divineApi, QueueMessage, ClientConfig } from '../../src/services/divine';

interface MessageComposerProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccess: () => void;
  // If editMessage is provided, we're editing a failed message for retry
  editMessage?: QueueMessage;
  // Available clients for selection
  clients?: ClientConfig[];
}

const MessageComposer: React.FC<MessageComposerProps> = ({
  isOpen,
  onClose,
  onSuccess,
  editMessage,
  clients = []
}) => {
  const [channel, setChannel] = useState<'sms' | 'email'>('sms');
  const [clientId, setClientId] = useState('');
  const [recipient, setRecipient] = useState('');
  const [subject, setSubject] = useState('');
  const [body, setBody] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Pre-fill if editing
  useEffect(() => {
    if (editMessage) {
      setChannel(editMessage.channel);
      setClientId(editMessage.clientId);
      setRecipient(editMessage.recipient);
      setSubject(editMessage.subject || '');
      setBody(editMessage.body);
    }
  }, [editMessage]);

  const handleSend = async () => {
    setError(null);

    // Validation
    if (!clientId && !editMessage) {
      setError('Please select a client');
      return;
    }
    if (!recipient && !editMessage) {
      setError('Recipient is required');
      return;
    }
    if (channel === 'email' && !subject) {
      setError('Subject is required for email');
      return;
    }
    if (!body.trim()) {
      setError('Message body is required');
      return;
    }

    setIsSending(true);

    try {
      if (editMessage) {
        // Edit and retry
        await divineApi.retryMessageWithEdit(editMessage.id, {
          body,
          subject: channel === 'email' ? subject : undefined
        });
      } else {
        // Send new manual message
        await divineApi.sendManualMessage({
          clientId,
          channel,
          recipient,
          subject: channel === 'email' ? subject : undefined,
          body
        });
      }

      onSuccess();
      onClose();

      // Reset form
      setChannel('sms');
      setClientId('');
      setRecipient('');
      setSubject('');
      setBody('');
    } catch (err: any) {
      setError(err.message || 'Failed to send message');
    } finally {
      setIsSending(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4"
      onClick={onClose}
    >
      <div
        className="bg-[#0A0A0A] border border-xlnc-gold/20 w-full max-w-lg"
        onClick={e => e.stopPropagation()}
      >
        {/* Header */}
        <div className="border-b border-white/10 p-4 flex items-center justify-between">
          <h3 className="text-sm font-bold text-white uppercase tracking-wider">
            {editMessage ? 'Edit & Retry Message' : 'Compose Message'}
          </h3>
          <button onClick={onClose} className="text-gray-500 hover:text-white">
            <X size={18} />
          </button>
        </div>

        {/* Content */}
        <div className="p-6 space-y-4">
          {/* Error Display */}
          {error && (
            <div className="bg-red-500/10 border border-red-500/30 p-3 flex items-center gap-2 text-red-500 text-sm">
              <AlertCircle size={16} />
              {error}
            </div>
          )}

          {/* Channel Selection (disabled when editing) */}
          <div>
            <label className="text-[9px] text-gray-500 uppercase block mb-2">Channel</label>
            <div className="flex gap-2">
              <button
                onClick={() => !editMessage && setChannel('sms')}
                disabled={!!editMessage}
                className={`flex items-center gap-2 px-4 py-2 text-sm border transition-all ${
                  channel === 'sms'
                    ? 'border-blue-500 bg-blue-500/10 text-blue-500'
                    : 'border-white/10 text-gray-500 hover:text-white'
                } ${editMessage ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                <MessageSquare size={14} />
                SMS
              </button>
              <button
                onClick={() => !editMessage && setChannel('email')}
                disabled={!!editMessage}
                className={`flex items-center gap-2 px-4 py-2 text-sm border transition-all ${
                  channel === 'email'
                    ? 'border-purple-500 bg-purple-500/10 text-purple-500'
                    : 'border-white/10 text-gray-500 hover:text-white'
                } ${editMessage ? 'opacity-50 cursor-not-allowed' : ''}`}
              >
                <Mail size={14} />
                Email
              </button>
            </div>
          </div>

          {/* Client Selection (only for new messages) */}
          {!editMessage && (
            <div>
              <label className="text-[9px] text-gray-500 uppercase block mb-1">Client</label>
              <select
                value={clientId}
                onChange={e => setClientId(e.target.value)}
                className="w-full bg-black/50 border border-white/10 px-3 py-2 text-sm text-white focus:border-xlnc-gold/50 outline-none"
              >
                <option value="">Select a client...</option>
                {clients.map(c => (
                  <option key={c.client_id} value={c.client_id}>
                    {c.business_name} ({c.client_id})
                  </option>
                ))}
              </select>
            </div>
          )}

          {/* Recipient */}
          <div>
            <label className="text-[9px] text-gray-500 uppercase block mb-1">
              {channel === 'sms' ? 'Phone Number' : 'Email Address'}
            </label>
            <input
              type={channel === 'sms' ? 'tel' : 'email'}
              value={recipient}
              onChange={e => setRecipient(e.target.value)}
              disabled={!!editMessage}
              placeholder={channel === 'sms' ? '+1234567890' : 'email@example.com'}
              className={`w-full bg-black/50 border border-white/10 px-3 py-2 text-sm text-white focus:border-xlnc-gold/50 outline-none ${
                editMessage ? 'opacity-50 cursor-not-allowed' : ''
              }`}
            />
          </div>

          {/* Subject (email only) */}
          {channel === 'email' && (
            <div>
              <label className="text-[9px] text-gray-500 uppercase block mb-1">Subject</label>
              <input
                type="text"
                value={subject}
                onChange={e => setSubject(e.target.value)}
                placeholder="Email subject..."
                className="w-full bg-black/50 border border-white/10 px-3 py-2 text-sm text-white focus:border-xlnc-gold/50 outline-none"
              />
            </div>
          )}

          {/* Body */}
          <div>
            <label className="text-[9px] text-gray-500 uppercase block mb-1">
              Message {channel === 'sms' && `(${body.length}/160)`}
            </label>
            <textarea
              value={body}
              onChange={e => setBody(e.target.value)}
              rows={channel === 'sms' ? 3 : 6}
              placeholder={channel === 'sms' ? 'Your SMS message...' : 'Your email content (HTML supported)...'}
              className="w-full bg-black/50 border border-white/10 px-3 py-2 text-sm text-white focus:border-xlnc-gold/50 outline-none resize-none"
            />
            {channel === 'sms' && body.length > 160 && (
              <div className="text-[10px] text-yellow-500 mt-1">
                Message exceeds 160 characters. It may be sent as multiple SMS.
              </div>
            )}
          </div>

          {/* Edit note */}
          {editMessage && (
            <div className="bg-yellow-500/10 border border-yellow-500/30 p-3 text-[11px] text-yellow-500">
              Editing will reset retry attempts and queue the message immediately.
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="border-t border-white/10 p-4 flex justify-end gap-3">
          <button
            onClick={onClose}
            className="text-[10px] font-bold uppercase px-4 py-2 border border-white/10 text-gray-400 hover:bg-white/5 transition-all"
          >
            Cancel
          </button>
          <button
            onClick={handleSend}
            disabled={isSending}
            className="text-[10px] font-bold uppercase px-4 py-2 bg-xlnc-gold text-black hover:bg-xlnc-gold/90 transition-all disabled:opacity-50 flex items-center gap-2"
          >
            {isSending ? (
              <Loader size={12} className="animate-spin" />
            ) : (
              <Send size={12} />
            )}
            {editMessage ? 'Retry' : 'Send'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default MessageComposer;
```

Add export to components/divine/index.ts:

```typescript
export { default as MessageComposer } from './MessageComposer';
```
  </action>
  <verify>Component compiles. Export added to index.</verify>
  <done>MessageComposer component created with compose and edit-retry modes</done>
</task>

<task type="auto">
  <name>Task 3: Add API Methods and Integrate Composer into Dashboard</name>
  <files>src/services/divine.ts, components/divine/MessageQueueViewer.tsx</files>
  <action>
Add the new API methods to the divine service:

In src/services/divine.ts:

```typescript
// Add to divineApi object
async sendManualMessage(params: {
  clientId: string;
  channel: 'sms' | 'email';
  recipient: string;
  subject?: string;
  body: string;
  scheduledFor?: string;
}): Promise<{ message: QueueMessage; queued: boolean }> {
  const response = await api.post('/divine/queue/manual', params);
  return response.data.data;
},

async retryMessageWithEdit(messageId: string, edits: {
  body: string;
  subject?: string;
}): Promise<{ retried: boolean; edited: boolean }> {
  const response = await api.post(`/divine/queue/retry/${messageId}/edit`, edits);
  return response.data.data;
},

async getScheduledMessages(params?: { clientId?: string; hours?: number }): Promise<{ messages: QueueMessage[]; total: number }> {
  const response = await api.get('/divine/queue/scheduled', { params });
  return response.data.data;
},

async getDeadLetterMessages(clientId?: string): Promise<{ messages: QueueMessage[]; total: number }> {
  const response = await api.get('/divine/queue/dead-letter', { params: { clientId } });
  return response.data.data;
},
```

In MessageQueueViewer.tsx, add composer integration:

```typescript
// Add imports
import { MessageComposer } from './index';

// Add state
const [isComposerOpen, setIsComposerOpen] = useState(false);
const [editingMessage, setEditingMessage] = useState<QueueMessage | null>(null);
const [clients, setClients] = useState<ClientConfig[]>([]);

// Load clients for composer
useEffect(() => {
  divineApi.getAllClients().then(data => setClients(data.clients)).catch(console.error);
}, []);

// Add compose button to header
<button
  onClick={() => {
    setEditingMessage(null);
    setIsComposerOpen(true);
  }}
  className="text-[10px] text-xlnc-gold font-bold uppercase tracking-wider border border-xlnc-gold/30 px-4 py-2 hover:bg-xlnc-gold/10 transition-colors flex items-center gap-2"
>
  <Plus size={12} />
  Compose
</button>

// In message expanded actions, add Edit & Retry button for failed/dead_letter
{(message.status === 'failed' || message.status === 'dead_letter') && (
  <button
    onClick={(e) => {
      e.stopPropagation();
      setEditingMessage(message);
      setIsComposerOpen(true);
    }}
    className="flex items-center gap-1 text-[9px] font-bold uppercase px-3 py-1.5 border border-blue-500/30 text-blue-500 hover:bg-blue-500/10 transition-all"
  >
    <Edit size={10} />
    Edit & Retry
  </button>
)}

// Add composer modal at end of component
<MessageComposer
  isOpen={isComposerOpen}
  onClose={() => {
    setIsComposerOpen(false);
    setEditingMessage(null);
  }}
  onSuccess={loadData}
  editMessage={editingMessage || undefined}
  clients={clients}
/>
```

Import Plus and Edit from lucide-react.
  </action>
  <verify>API methods work. Composer opens from dashboard. Edit & Retry works on failed messages.</verify>
  <done>API methods added, MessageComposer integrated into dashboard with compose and edit-retry</done>
</task>

</tasks>

<verification>
1. Run `npm run build` in backend - all compiles
2. Run `npm run build` in frontend - all compiles
3. Open dashboard, click Compose - modal opens
4. Fill out form and send - message appears in queue
5. Find failed message, click Edit & Retry - modal opens with content pre-filled
6. Edit and retry - message requeued
</verification>

<success_criteria>
- POST /divine/queue/manual creates manual messages with messageType 'manual'
- POST /divine/queue/retry/:id/edit allows editing before retry
- MessageComposer component supports both compose and edit modes
- Compose button in MessageQueueViewer header
- Edit & Retry button on failed/dead letter messages
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-follow-up-messaging/04-05-SUMMARY.md`
</output>
