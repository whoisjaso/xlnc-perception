---
phase: 06.1-client-onboarding-oauth-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/divine/token-health.service.ts
  - backend/src/db/schema/oauthTokens.ts
autonomous: true

must_haves:
  truths:
    - "System periodically checks all OAuth tokens and detects unhealthy ones"
    - "Admins are alerted via existing alerting service when tokens are invalid or refresh fails"
    - "Token health status is queryable per client"
  artifacts:
    - path: "backend/src/services/divine/token-health.service.ts"
      provides: "Token health monitoring with periodic checks and alerting"
      min_lines: 80
    - path: "backend/src/db/schema/oauthTokens.ts"
      provides: "Updated schema with tokenStatus column"
      contains: "tokenStatus"
  key_links:
    - from: "backend/src/services/divine/token-health.service.ts"
      to: "backend/src/services/divine/oauth-token.service.ts"
      via: "reads token records and attempts refresh"
      pattern: "oauthTokenService"
    - from: "backend/src/services/divine/token-health.service.ts"
      to: "backend/src/services/divine/alerting.service.ts"
      via: "sends alerts on unhealthy tokens"
      pattern: "alertingService"
---

<objective>
Create OAuth token health monitoring that periodically checks all tokens and alerts admins when tokens are expired, invalid, or failing to refresh.

Purpose: Without health monitoring, expired Zoho tokens silently break CRM/Calendar integrations. Admins need proactive alerts and visibility.
Output: TokenHealthService that runs periodic checks, updates token status, and triggers alerts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06.1-client-onboarding-oauth-hardening/06.1-RESEARCH.md
@backend/src/services/divine/oauth-token.service.ts
@backend/src/db/schema/oauthTokens.ts
@backend/src/services/divine/alerting.service.ts
@backend/src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tokenStatus to oauthTokens schema</name>
  <files>backend/src/db/schema/oauthTokens.ts</files>
  <action>
    Add a `tokenStatus` column to the oauthTokens schema:
    - Type: varchar('token_status', { length: 20 }), default 'healthy'
    - Valid values: 'healthy', 'expiring', 'refresh_failed', 'invalid'
    - Also add `lastHealthCheck` timestamp column (nullable)
    - Also add `healthCheckError` text column (nullable) for storing last error message

    Create a migration file for these new columns at `backend/src/db/migrations/add-token-health-columns.ts`.
    Follow the pattern of existing migrations.
  </action>
  <verify>TypeScript compiles without errors on the schema file</verify>
  <done>oauthTokens schema has tokenStatus, lastHealthCheck, and healthCheckError columns</done>
</task>

<task type="auto">
  <name>Task 2: Create TokenHealthService with periodic monitoring</name>
  <files>backend/src/services/divine/token-health.service.ts</files>
  <action>
    Create `backend/src/services/divine/token-health.service.ts`:

    **TokenHealthReport interface:**
    - clientId, provider, status ('healthy'|'expiring'|'refresh_failed'|'invalid'), lastRefresh (Date|null), error (string|null)

    **Class TokenHealthService:**

    **checkAllTokens(): Promise<TokenHealthReport[]>**
    1. Select all records from oauth_tokens table
    2. For each token:
       - If no refreshToken -> status 'invalid'
       - If tokenExpiry exists and expires within 1 hour:
         - Try oauthTokenService.getAccessToken() to proactively refresh
         - If refresh succeeds -> 'healthy'
         - If error contains 'invalid_grant' or 'invalid_code' -> 'invalid'
         - Otherwise -> 'refresh_failed'
       - If tokenExpiry is null or > 1 hour away -> 'healthy'
    3. Update oauth_tokens record: set tokenStatus, lastHealthCheck = now, healthCheckError = error message or null
    4. Return array of TokenHealthReport

    **checkClientTokens(clientId: string): Promise<TokenHealthReport[]>**
    - Same as above but filtered to specific clientId

    **alertOnUnhealthy(reports: TokenHealthReport[]): void**
    - Filter reports where status is 'invalid' or 'refresh_failed'
    - For each unhealthy token, call alertingService.sendAlert with:
      - severity: 'critical' for 'invalid', 'error' for 'refresh_failed'
      - title: `OAuth Token ${status}: ${clientId}/${provider}`
      - message: includes error details and instruction to re-authorize
    - Use existing alertingService (already has Slack + email + SMS channels)

    **startPeriodicCheck(intervalMinutes: number = 30): void**
    - Use setInterval to run checkAllTokens + alertOnUnhealthy every intervalMinutes
    - Log start message
    - Store interval ref for cleanup

    **stopPeriodicCheck(): void**
    - Clear the interval

    Export singleton: `export const tokenHealthService = new TokenHealthService();`

    Start periodic check in the service's constructor or export a startup function. Look at how other services initialize (e.g., queueProcessorService) and follow the same pattern.

    Import clientConfigService for getting Zoho credentials needed by getAccessToken.
  </action>
  <verify>TypeScript compiles. Service can be imported without errors.</verify>
  <done>
    - TokenHealthService checks all tokens and detects unhealthy states
    - Unhealthy tokens trigger alerts via alertingService
    - Periodic check runs every 30 minutes
    - Token status persisted to database
  </done>
</task>

</tasks>

<verification>
- oauthTokens schema includes tokenStatus, lastHealthCheck, healthCheckError
- TokenHealthService compiles and exports singleton
- checkAllTokens queries DB, attempts refresh for expiring tokens, updates status
- alertOnUnhealthy calls alertingService for invalid/failed tokens
- Periodic check configurable with setInterval
</verification>

<success_criteria>
Token health monitoring runs periodically, detects expired/invalid tokens, persists status to DB, and alerts admins via existing alerting channels.
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-client-onboarding-oauth-hardening/06.1-02-SUMMARY.md`
</output>
