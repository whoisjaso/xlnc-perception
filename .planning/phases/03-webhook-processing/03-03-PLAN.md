---
phase: 03-webhook-processing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema/webhookEvents.ts
  - backend/src/routes/webhooks.ts
  - backend/src/services/divine/webhook-idempotency.service.ts
autonomous: true

must_haves:
  truths:
    - "Duplicate webhooks are detected and rejected"
    - "Idempotency key is call_id + event_type combination"
    - "Duplicate processing returns 200 OK without reprocessing"
  artifacts:
    - path: "backend/src/db/schema/webhookEvents.ts"
      provides: "Schema with clientId and idempotencyKey columns"
      contains: "idempotencyKey"
    - path: "backend/src/services/divine/webhook-idempotency.service.ts"
      provides: "Idempotency checking service"
      exports: ["webhookIdempotencyService", "checkIdempotency"]
  key_links:
    - from: "backend/src/routes/webhooks.ts"
      to: "backend/src/services/divine/webhook-idempotency.service.ts"
      via: "import and check before processing"
      pattern: "webhookIdempotencyService\\.check"
---

<objective>
Implement idempotent webhook handling to prevent duplicate event processing.

Purpose: REQ-001 requires idempotent handling so duplicate webhooks don't cause issues. Retell may retry webhooks up to 3 times if no 2xx response is received. Without idempotency, the same event could be processed multiple times.

Output: Webhooks are deduplicated by call_id + event_type. Duplicates return 200 OK without reprocessing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-webhook-processing/03-RESEARCH.md

# Key source files
@backend/src/db/schema/webhookEvents.ts
@backend/src/routes/webhooks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update webhookEvents schema with idempotency key</name>
  <files>backend/src/db/schema/webhookEvents.ts</files>
  <action>
Update the webhookEvents schema to include clientId and idempotencyKey columns:

```typescript
import { pgTable, uuid, varchar, boolean, timestamp, jsonb, uniqueIndex } from 'drizzle-orm/pg-core';

export const webhookEvents = pgTable('webhook_events', {
  id: uuid('id').primaryKey().defaultRandom(),
  eventType: varchar('event_type', { length: 100 }),
  retellCallId: varchar('retell_call_id', { length: 255 }),
  clientId: varchar('client_id', { length: 100 }),
  idempotencyKey: varchar('idempotency_key', { length: 400 }),
  payload: jsonb('payload'),
  processed: boolean('processed').notNull().default(false),
  processedAt: timestamp('processed_at'),
  createdAt: timestamp('created_at').notNull().defaultNow(),
}, (table) => ({
  // Unique index on idempotency key to prevent duplicates
  idempotencyKeyIdx: uniqueIndex('webhook_events_idempotency_key_idx').on(table.idempotencyKey),
}));

export type WebhookEvent = typeof webhookEvents.$inferSelect;
export type NewWebhookEvent = typeof webhookEvents.$inferInsert;

/**
 * Generate an idempotency key for a webhook event.
 * Format: {clientId}:{callId}:{eventType}
 */
export function generateIdempotencyKey(
  clientId: string,
  callId: string,
  eventType: string
): string {
  return `${clientId}:${callId}:${eventType}`;
}
```

After updating the schema, run a database migration:
```bash
cd backend && npx drizzle-kit generate --name add-webhook-idempotency
cd backend && npx drizzle-kit push
```
  </action>
  <verify>
1. Schema has idempotencyKey column: `grep "idempotencyKey" backend/src/db/schema/webhookEvents.ts`
2. Unique index defined: `grep "uniqueIndex" backend/src/db/schema/webhookEvents.ts`
3. Migration generated and applied: `cd backend && npx drizzle-kit push`
  </verify>
  <done>webhookEvents schema has idempotencyKey column with unique index.</done>
</task>

<task type="auto">
  <name>Task 2: Create webhook idempotency service</name>
  <files>backend/src/services/divine/webhook-idempotency.service.ts</files>
  <action>
Create a new service to handle webhook idempotency checking:

```typescript
/**
 * Webhook Idempotency Service
 * Prevents duplicate webhook processing using call_id + event_type combination.
 */
import { db } from '../../config/database';
import { webhookEvents, generateIdempotencyKey } from '../../db/schema/webhookEvents';
import { eq } from 'drizzle-orm';
import { logger } from '../../utils/logger';

export interface IdempotencyCheckResult {
  isDuplicate: boolean;
  existingEventId?: string;
  processedAt?: Date;
}

export class WebhookIdempotencyService {
  /**
   * Check if a webhook event has already been processed.
   * Returns isDuplicate: true if this event was already handled.
   */
  async check(
    clientId: string,
    callId: string,
    eventType: string
  ): Promise<IdempotencyCheckResult> {
    const idempotencyKey = generateIdempotencyKey(clientId, callId, eventType);

    try {
      const existing = await db
        .select({
          id: webhookEvents.id,
          processed: webhookEvents.processed,
          processedAt: webhookEvents.processedAt,
        })
        .from(webhookEvents)
        .where(eq(webhookEvents.idempotencyKey, idempotencyKey))
        .limit(1);

      if (existing.length > 0) {
        logger.info({
          idempotencyKey,
          existingEventId: existing[0].id,
          wasProcessed: existing[0].processed,
        }, 'Duplicate webhook detected');

        return {
          isDuplicate: true,
          existingEventId: existing[0].id,
          processedAt: existing[0].processedAt || undefined,
        };
      }

      return { isDuplicate: false };
    } catch (error) {
      // On error, allow processing (fail open) to avoid blocking legitimate events
      logger.error({ error, idempotencyKey }, 'Idempotency check failed, allowing event');
      return { isDuplicate: false };
    }
  }

  /**
   * Record a webhook event with its idempotency key.
   * Call this BEFORE processing to claim the event.
   */
  async record(
    clientId: string,
    callId: string,
    eventType: string,
    payload: unknown
  ): Promise<string> {
    const idempotencyKey = generateIdempotencyKey(clientId, callId, eventType);

    try {
      const [event] = await db
        .insert(webhookEvents)
        .values({
          eventType,
          retellCallId: callId,
          clientId,
          idempotencyKey,
          payload,
          processed: false,
        })
        .returning({ id: webhookEvents.id });

      return event.id;
    } catch (error: any) {
      // Check for unique constraint violation (duplicate)
      if (error.code === '23505' || error.message?.includes('unique constraint')) {
        logger.info({ idempotencyKey }, 'Concurrent duplicate detected via constraint');
        throw new DuplicateWebhookError(idempotencyKey);
      }
      throw error;
    }
  }

  /**
   * Mark a webhook event as processed.
   */
  async markProcessed(eventId: string): Promise<void> {
    await db
      .update(webhookEvents)
      .set({
        processed: true,
        processedAt: new Date(),
      })
      .where(eq(webhookEvents.id, eventId));
  }

  /**
   * Combined check-and-record operation.
   * Returns the event ID if new, throws DuplicateWebhookError if duplicate.
   */
  async checkAndRecord(
    clientId: string,
    callId: string,
    eventType: string,
    payload: unknown
  ): Promise<{ eventId: string; isDuplicate: false } | { isDuplicate: true }> {
    // First check if exists
    const checkResult = await this.check(clientId, callId, eventType);
    if (checkResult.isDuplicate) {
      return { isDuplicate: true };
    }

    // Try to record (handles race conditions via unique constraint)
    try {
      const eventId = await this.record(clientId, callId, eventType, payload);
      return { eventId, isDuplicate: false };
    } catch (error) {
      if (error instanceof DuplicateWebhookError) {
        return { isDuplicate: true };
      }
      throw error;
    }
  }
}

/**
 * Error thrown when a duplicate webhook is detected.
 */
export class DuplicateWebhookError extends Error {
  constructor(public idempotencyKey: string) {
    super(`Duplicate webhook: ${idempotencyKey}`);
    this.name = 'DuplicateWebhookError';
  }
}

export const webhookIdempotencyService = new WebhookIdempotencyService();
```
  </action>
  <verify>
1. Service file exists: `test -f backend/src/services/divine/webhook-idempotency.service.ts`
2. TypeScript compiles: `cd backend && npx tsc --noEmit`
3. Exports correct: `grep "export.*webhookIdempotencyService" backend/src/services/divine/webhook-idempotency.service.ts`
  </verify>
  <done>Webhook idempotency service created with check, record, and markProcessed methods.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate idempotency check into webhook routes</name>
  <files>backend/src/routes/webhooks.ts</files>
  <action>
Update webhooks.ts to use idempotency checking:

1. Add import at top of file:
```typescript
import { webhookIdempotencyService } from '../services/divine/webhook-idempotency.service';
import { generateIdempotencyKey } from '../db/schema/webhookEvents';
```

2. Update processRetellWebhook function to check idempotency BEFORE processing:

Replace the existing webhook event storage (lines ~96-104) with idempotency-aware logic:

```typescript
  const webhookData = req.body;
  const eventType = webhookData.event || 'call_ended';
  const callId = webhookData.call?.call_id || webhookData.call_id;

  logTheatrical.info(`Retell webhook received for client ${clientConfig.client_id}: ${eventType}`);

  // Check idempotency BEFORE processing
  const idempotencyResult = await webhookIdempotencyService.checkAndRecord(
    clientConfig.client_id,
    callId,
    eventType,
    webhookData
  );

  if (idempotencyResult.isDuplicate) {
    logTheatrical.info(`Duplicate webhook ignored: ${clientConfig.client_id}:${callId}:${eventType}`);
    // Return 200 OK to prevent Retell retries
    return res.status(200).json({
      success: true,
      message: 'Webhook already processed (duplicate)',
      client: clientConfig.client_id,
      event: eventType,
      duplicate: true,
    });
  }

  const webhookEventId = idempotencyResult.eventId;

  try {
    // ... existing processing logic ...
```

3. At the end of successful processing, mark the event as processed:

Before the final res.status(200).json response:
```typescript
    // Mark webhook as processed
    await webhookIdempotencyService.markProcessed(webhookEventId);

    res.status(200).json({
      success: true,
      message: 'Webhook processed by Divine System',
      client: clientConfig.client_id,
      event: eventType,
      decision: decision.action
    });
```

4. Remove the old webhook event storage code (the db.insert into webhookEvents) since idempotency service handles it.

5. Also remove the old "Mark webhook as processed" code (lines ~187-191) since idempotency service handles it.
  </action>
  <verify>
1. TypeScript compiles: `cd backend && npx tsc --noEmit`
2. Idempotency service imported: `grep "webhookIdempotencyService" backend/src/routes/webhooks.ts`
3. Duplicate check before processing: `grep -A5 "checkAndRecord" backend/src/routes/webhooks.ts`
4. Duplicate response returns 200: `grep -B2 -A2 "duplicate.*true" backend/src/routes/webhooks.ts`
  </verify>
  <done>Webhook routes check idempotency before processing and return 200 OK for duplicates.</done>
</task>

</tasks>

<verification>
Phase 03 Plan 03 verification:
1. TypeScript compiles: `cd backend && npx tsc --noEmit`
2. Database migration applied: `cd backend && npx drizzle-kit push`
3. Idempotency service exists: `test -f backend/src/services/divine/webhook-idempotency.service.ts`
4. Routes use idempotency: `grep "idempotencyResult.isDuplicate" backend/src/routes/webhooks.ts`

Manual test:
1. Send a test webhook to `/api/webhooks/retell/smart-tax-nation`
2. Send the SAME webhook again with same call_id and event_type
3. Second request should return `{ duplicate: true }` without reprocessing
</verification>

<success_criteria>
- webhookEvents schema has idempotencyKey column with unique index
- Idempotency service checks for duplicates before processing
- Duplicate webhooks return 200 OK with `duplicate: true`
- Database migration applied successfully
- No duplicate processing occurs for retried webhooks
</success_criteria>

<output>
After completion, create `.planning/phases/03-webhook-processing/03-03-SUMMARY.md`
</output>
