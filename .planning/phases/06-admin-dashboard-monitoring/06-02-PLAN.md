---
phase: 06-admin-dashboard-monitoring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/divine/webhook-handler.service.ts
  - backend/src/index.ts
  - src/hooks/useCallSocket.ts
  - components/divine/CallStatusPanel.tsx
  - components/divine/index.ts
autonomous: true

must_haves:
  truths:
    - "Call started event emits to admin WebSocket room"
    - "Call ended event emits to admin WebSocket room"
    - "Dashboard can display active and recent calls in real-time"
  artifacts:
    - path: "backend/src/services/divine/webhook-handler.service.ts"
      provides: "WebSocket call event emissions"
      contains: "io.to('admin').emit('call:started'"
    - path: "src/hooks/useCallSocket.ts"
      provides: "WebSocket hook for call events"
      exports: ["useCallSocket"]
    - path: "components/divine/CallStatusPanel.tsx"
      provides: "Real-time call status display component"
      min_lines: 80
  key_links:
    - from: "backend/src/services/divine/webhook-handler.service.ts"
      to: "Socket.IO server"
      via: "setSocketServer method"
      pattern: "this\\.io\\?.to\\('admin'\\)\\.emit"
    - from: "src/hooks/useCallSocket.ts"
      to: "socket.io-client"
      via: "io() connection"
      pattern: "socket\\.on\\('call:"
---

<objective>
Add real-time call status via WebSocket events.

Purpose: The dashboard currently has no way to see live call activity. While conversations are stored in the database, there are no WebSocket events emitted when calls start or end. This prevents real-time monitoring of active calls.

Output: WebSocket events for call lifecycle, frontend hook to consume them, and CallStatusPanel component showing live/recent calls.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-admin-dashboard-monitoring/06-RESEARCH.md

Key existing patterns:
- backend/src/services/divine/webhook-handler.service.ts - handleCallStarted and handleCallEnded methods
- backend/src/index.ts - Socket.IO server setup at lines 78-110, setSocketServer pattern used
- src/hooks/useSocketMessages.ts - Pattern for WebSocket hooks with connect/reconnect
- src/hooks/useErrorSocket.ts - Pattern for joining admin/client rooms
- queueProcessorService has setSocketServer(io) - established pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebSocket emissions to webhookHandlerService</name>
  <files>backend/src/services/divine/webhook-handler.service.ts, backend/src/index.ts</files>
  <action>
1. In webhook-handler.service.ts, add Socket.IO server reference and setter method:

Add import at top:
```typescript
import { Server as SocketServer } from 'socket.io';
```

Add private field and setter to WebhookHandlerService class (after the eventHandlers map):
```typescript
private io: SocketServer | null = null;

setSocketServer(io: SocketServer): void {
  this.io = io;
  logger.info('WebhookHandlerService Socket.IO server attached');
}
```

2. In handleCallStarted method (after the conversationService.startConversation call, around line 146), add WebSocket emission:
```typescript
// Emit call started event to WebSocket
if (this.io) {
  const callEvent = {
    callId: call.call_id,
    clientId: config.client_id,
    phone: phone.slice(-4), // Last 4 digits only for privacy
    direction: call.direction || 'inbound',
    agentId: call.agent_id,
    timestamp: new Date().toISOString(),
  };
  this.io.to('admin').emit('call:started', callEvent);
  this.io.to(`client:${config.client_id}`).emit('call:started', callEvent);
  logger.debug({ callId: call.call_id }, 'Emitted call:started event');
}
```

3. In handleCallEnded method (before the return statement, around line 173), add WebSocket emission:
```typescript
// Emit call ended event to WebSocket
if (this.io) {
  const callEvent = {
    callId: call.call_id,
    clientId: config.client_id,
    durationMs: call.duration_ms,
    status: call.call_status,
    timestamp: new Date().toISOString(),
  };
  this.io.to('admin').emit('call:ended', callEvent);
  this.io.to(`client:${config.client_id}`).emit('call:ended', callEvent);
  logger.debug({ callId: call.call_id }, 'Emitted call:ended event');
}
```

4. In backend/src/index.ts, wire up the webhookHandlerService to receive the Socket.IO server.

Add import near the top with other divine service imports:
```typescript
import { webhookHandlerService } from './services/divine';
```

After the existing setSocketServer calls (around line 100), add:
```typescript
webhookHandlerService.setSocketServer(io);
```
  </action>
  <verify>Backend compiles. Check logs show "WebhookHandlerService Socket.IO server attached" on startup.</verify>
  <done>webhookHandlerService emits call:started and call:ended events to WebSocket rooms</done>
</task>

<task type="auto">
  <name>Task 2: Create useCallSocket hook</name>
  <files>src/hooks/useCallSocket.ts</files>
  <action>
Create src/hooks/useCallSocket.ts following the established hook patterns:

```typescript
// Divine Agentic Intelligence System - WebSocket Hook for Real-time Call Events
// Connects to Socket.IO for live call status streaming

import { useState, useEffect, useCallback, useRef } from 'react';
import { io, Socket } from 'socket.io-client';
import { useAuthStore } from '../stores/useAuthStore';

export interface CallEvent {
  callId: string;
  clientId: string;
  phone?: string; // Last 4 digits
  direction?: 'inbound' | 'outbound';
  agentId?: string;
  durationMs?: number;
  status?: string;
  timestamp: string;
}

export interface ActiveCall extends CallEvent {
  startedAt: string;
}

export interface UseCallSocketReturn {
  activeCalls: ActiveCall[];
  recentCalls: CallEvent[];
  isConnected: boolean;
  reconnect: () => void;
}

export function useCallSocket(serverUrl?: string): UseCallSocketReturn {
  const socketRef = useRef<Socket | null>(null);
  const [activeCalls, setActiveCalls] = useState<ActiveCall[]>([]);
  const [recentCalls, setRecentCalls] = useState<CallEvent[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const { accessToken, user } = useAuthStore();

  const connect = useCallback(() => {
    const url = serverUrl || import.meta.env.VITE_API_URL || 'http://localhost:3001';

    if (socketRef.current?.connected) {
      return socketRef.current;
    }

    const newSocket = io(url, {
      transports: ['websocket', 'polling'],
      auth: { token: accessToken },
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    newSocket.on('connect', () => {
      console.log('[CallSocket] Connected');
      setIsConnected(true);

      // Join admin room for admin users
      if (user?.isAdmin) {
        newSocket.emit('join:admin');
        console.log('[CallSocket] Joined admin room');
      }

      // Join client room if user has clientId
      if (user?.clientId) {
        newSocket.emit('join:client', user.clientId);
        console.log(`[CallSocket] Joined client room: ${user.clientId}`);
      }
    });

    newSocket.on('disconnect', () => {
      console.log('[CallSocket] Disconnected');
      setIsConnected(false);
    });

    newSocket.on('call:started', (data: CallEvent) => {
      console.log('[CallSocket] Call started:', data.callId);
      setActiveCalls(prev => [
        { ...data, startedAt: data.timestamp },
        ...prev.filter(c => c.callId !== data.callId)
      ]);
    });

    newSocket.on('call:ended', (data: CallEvent) => {
      console.log('[CallSocket] Call ended:', data.callId);
      // Remove from active, add to recent
      setActiveCalls(prev => prev.filter(c => c.callId !== data.callId));
      setRecentCalls(prev => [data, ...prev.slice(0, 19)]); // Keep last 20
    });

    socketRef.current = newSocket;
    return newSocket;
  }, [serverUrl, accessToken, user?.isAdmin, user?.clientId]);

  useEffect(() => {
    if (!accessToken) return;

    const sock = connect();
    return () => {
      sock?.disconnect();
      socketRef.current = null;
    };
  }, [connect, accessToken]);

  const reconnect = useCallback(() => {
    if (socketRef.current) {
      socketRef.current.disconnect();
      socketRef.current = null;
    }
    connect();
  }, [connect]);

  return { activeCalls, recentCalls, isConnected, reconnect };
}

export default useCallSocket;
```
  </action>
  <verify>TypeScript compiles. Hook exports correctly.</verify>
  <done>useCallSocket hook created with activeCalls and recentCalls state management</done>
</task>

<task type="auto">
  <name>Task 3: Create CallStatusPanel component</name>
  <files>components/divine/CallStatusPanel.tsx, components/divine/index.ts</files>
  <action>
1. Create components/divine/CallStatusPanel.tsx:

```typescript
// Divine Agentic Intelligence System - Real-time Call Status Panel
// Displays active and recent calls via WebSocket

import React from 'react';
import {
  Phone,
  PhoneIncoming,
  PhoneOutgoing,
  PhoneOff,
  Clock,
  Wifi,
  WifiOff,
  RefreshCw
} from 'lucide-react';
import { useCallSocket, ActiveCall, CallEvent } from '../../src/hooks/useCallSocket';

interface CallStatusPanelProps {
  clientId?: string; // Optional filter by client
  showRecent?: boolean; // Show recent ended calls
  maxRecent?: number; // Max recent calls to show (default 5)
}

const CallStatusPanel: React.FC<CallStatusPanelProps> = ({
  clientId,
  showRecent = true,
  maxRecent = 5
}) => {
  const { activeCalls, recentCalls, isConnected, reconnect } = useCallSocket();

  // Filter by clientId if provided
  const filteredActive = clientId
    ? activeCalls.filter(c => c.clientId === clientId)
    : activeCalls;
  const filteredRecent = clientId
    ? recentCalls.filter(c => c.clientId === clientId).slice(0, maxRecent)
    : recentCalls.slice(0, maxRecent);

  const formatDuration = (ms?: number): string => {
    if (!ms) return '--';
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return minutes > 0 ? `${minutes}m ${secs}s` : `${secs}s`;
  };

  const getTimeSince = (timestamp: string): string => {
    const diff = Date.now() - new Date(timestamp).getTime();
    const seconds = Math.floor(diff / 1000);
    if (seconds < 60) return `${seconds}s ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    return new Date(timestamp).toLocaleTimeString();
  };

  return (
    <div className="bg-[#0A0A0A] border border-white/5 p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-3">
          <Phone size={18} className="text-xlnc-gold" />
          <h3 className="text-sm font-bold text-white uppercase tracking-wider">Call Status</h3>
        </div>
        <div className="flex items-center gap-3">
          <span className={`flex items-center gap-1 text-[9px] uppercase ${isConnected ? 'text-emerald-500' : 'text-red-500'}`}>
            {isConnected ? <Wifi size={10} /> : <WifiOff size={10} />}
            {isConnected ? 'Live' : 'Disconnected'}
          </span>
          <button
            onClick={reconnect}
            className="text-gray-500 hover:text-white transition-colors p-1"
            title="Reconnect"
          >
            <RefreshCw size={12} />
          </button>
        </div>
      </div>

      {/* Active Calls */}
      <div className="mb-4">
        <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-2 flex items-center gap-2">
          <div className="w-2 h-2 rounded-full bg-emerald-500 animate-pulse" />
          Active Calls ({filteredActive.length})
        </div>

        {filteredActive.length === 0 ? (
          <div className="text-center py-4 text-gray-600 border border-dashed border-white/10">
            <Phone size={20} className="mx-auto mb-2 opacity-30" />
            <div className="text-[10px]">No active calls</div>
          </div>
        ) : (
          <div className="space-y-2">
            {filteredActive.map((call) => (
              <div key={call.callId} className="flex items-center justify-between p-3 bg-emerald-500/10 border border-emerald-500/30">
                <div className="flex items-center gap-3">
                  {call.direction === 'outbound' ? (
                    <PhoneOutgoing size={14} className="text-emerald-500" />
                  ) : (
                    <PhoneIncoming size={14} className="text-emerald-500" />
                  )}
                  <div>
                    <div className="text-sm text-white font-medium">
                      ***{call.phone || '????'}
                    </div>
                    <div className="text-[9px] text-gray-500">
                      {call.direction || 'inbound'} â€¢ {call.clientId}
                    </div>
                  </div>
                </div>
                <div className="flex items-center gap-2 text-[10px] text-emerald-500">
                  <Clock size={10} />
                  {getTimeSince(call.startedAt)}
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Recent Calls */}
      {showRecent && (
        <div>
          <div className="text-[10px] text-gray-500 uppercase tracking-wider mb-2">
            Recent Calls
          </div>

          {filteredRecent.length === 0 ? (
            <div className="text-center py-4 text-gray-600">
              <div className="text-[10px]">No recent calls</div>
            </div>
          ) : (
            <div className="space-y-1">
              {filteredRecent.map((call) => (
                <div key={call.callId} className="flex items-center justify-between p-2 bg-white/[0.02] hover:bg-white/[0.04] transition-colors">
                  <div className="flex items-center gap-2">
                    <PhoneOff size={12} className="text-gray-500" />
                    <span className="text-[11px] text-gray-400">***{call.phone || '????'}</span>
                  </div>
                  <div className="flex items-center gap-3 text-[10px] text-gray-500">
                    <span>{formatDuration(call.durationMs)}</span>
                    <span>{getTimeSince(call.timestamp)}</span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default CallStatusPanel;
```

2. In components/divine/index.ts, add the export:

Add this line with the other exports:
```typescript
export { default as CallStatusPanel } from './CallStatusPanel';
```
  </action>
  <verify>Component renders without errors. Export works from index.</verify>
  <done>CallStatusPanel component displays active and recent calls from WebSocket events</done>
</task>

</tasks>

<verification>
1. Run `npm run build` in both backend and frontend - should compile without errors
2. Start backend server, check logs for "WebhookHandlerService Socket.IO server attached"
3. Start frontend, navigate to Divine Dashboard
4. CallStatusPanel should show "Live" connection status when WebSocket connects
5. Manual test: Trigger a test call_started event via Retell or mock, verify it appears in CallStatusPanel
6. When call ends, verify call moves from "Active" to "Recent"
</verification>

<success_criteria>
- WebhookHandlerService has setSocketServer method and emits call:started/call:ended events
- useCallSocket hook tracks active and recent calls
- CallStatusPanel displays real-time call status with connection indicator
- Events are emitted to both admin and client-specific rooms
- Phone numbers are masked (last 4 digits only) for privacy
</success_criteria>

<output>
After completion, create `.planning/phases/06-admin-dashboard-monitoring/06-02-SUMMARY.md`
</output>
